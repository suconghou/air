#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var process$1 = require('process');
var fs = require('fs');
var fs__default = _interopDefault(fs);
var path = require('path');
var path__default = _interopDefault(path);
var util$1 = require('util');
var querystring = require('querystring');
var http = require('http');
var child_process = require('child_process');
require('core-js/modules/es.string.trim-start');
require('core-js/modules/es.string.trim-end');
var requireRelative = _interopDefault(require('require-relative'));
var prettyFormat = _interopDefault(require('pretty-format'));
var commonTags = require('common-tags');
var indentString = _interopDefault(require('indent-string'));
var getLogger = _interopDefault(require('loglevel-colored-level-prefix'));
var merge = _interopDefault(require('lodash.merge'));
var delve = _interopDefault(require('dlv'));

const fsStat = util$1.promisify(fs.stat);
const fsAccess = util$1.promisify(fs.access);
const fsWriteFile = util$1.promisify(fs.writeFile);
const fsReadFile = util$1.promisify(fs.readFile);
const fsCopyFile = util$1.promisify(fs.copyFile);
const fsChmod = util$1.promisify(fs.chmod);
class util {
    static resolveLookupPaths(pathstr, file) {
        const arr = [];
        const tmp = [];
        pathstr.split(path.sep).forEach((item) => {
            if (/^[a-zA-Z]:$/.test(item)) {
                // for windows
                return;
            }
            tmp.push(item);
            arr.push(path.resolve(path.join(path.sep, ...tmp, file)));
        });
        return arr.reverse();
    }
    static async tryFiles(paths) {
        for (let i = 0, j = paths.length; i < j; i++) {
            const file = paths[i];
            try {
                await fsAccess(file, fs.constants.R_OK);
                return file;
            }
            catch (e) {
                // not exist try next
            }
        }
    }
    static async getConfig(cwd, name = 'static.json') {
        if (!/static\/?$/.test(cwd)) {
            cwd = path.join(cwd, 'static');
        }
        const paths = this.resolveLookupPaths(cwd, name);
        let f = '', json = {}, fpath = '', dirname = '';
        f = await this.tryFiles(paths);
        if (f) {
            json = require(f);
            fpath = f;
            dirname = path.dirname(f);
        }
        return { json, fpath, dirname };
    }
    static async getUpdateTime(files) {
        const mtimes = [];
        for (let i = 0, j = files.length; i < j; i++) {
            const v = files[i];
            const stat = await fsStat(v);
            mtimes.push(stat.mtime.getTime());
        }
        const updateTime = Math.max.apply(this, mtimes);
        return updateTime;
    }
    static async getContent(files) {
        const arr = files.map((file) => fsReadFile(file, 'utf-8'));
        const res = await Promise.all(arr);
        const objs = {};
        files.forEach((file, index) => {
            objs[file] = res[index];
        });
        return objs;
    }
}

const fsStat$1 = util$1.promisify(fs.stat);

const types = {
    'application/andrew-inset': ['ez'],
    'application/applixware': ['aw'],
    'application/atom+xml': ['atom'],
    'application/atomcat+xml': ['atomcat'],
    'application/atomsvc+xml': ['atomsvc'],
    'application/bdoc': ['bdoc'],
    'application/ccxml+xml': ['ccxml'],
    'application/cdmi-capability': ['cdmia'],
    'application/cdmi-container': ['cdmic'],
    'application/cdmi-domain': ['cdmid'],
    'application/cdmi-object': ['cdmio'],
    'application/cdmi-queue': ['cdmiq'],
    'application/cu-seeme': ['cu'],
    'application/dash+xml': ['mpd'],
    'application/davmount+xml': ['davmount'],
    'application/docbook+xml': ['dbk'],
    'application/dssc+der': ['dssc'],
    'application/dssc+xml': ['xdssc'],
    'application/ecmascript': ['ecma'],
    'application/emma+xml': ['emma'],
    'application/epub+zip': ['epub'],
    'application/exi': ['exi'],
    'application/font-tdpfr': ['pfr'],
    'application/font-woff': ['woff'],
    'application/geo+json': ['geojson'],
    'application/gml+xml': ['gml'],
    'application/gpx+xml': ['gpx'],
    'application/gxf': ['gxf'],
    'application/gzip': ['gz'],
    'application/hjson': ['hjson'],
    'application/hyperstudio': ['stk'],
    'application/inkml+xml': ['ink', 'inkml'],
    'application/ipfix': ['ipfix'],
    'application/java-archive': ['jar', 'war', 'ear'],
    'application/java-serialized-object': ['ser'],
    'application/java-vm': ['class'],
    'application/javascript': ['js', 'mjs'],
    'application/json': ['json', 'map'],
    'application/json5': ['json5'],
    'application/jsonml+json': ['jsonml'],
    'application/ld+json': ['jsonld'],
    'application/lost+xml': ['lostxml'],
    'application/mac-binhex40': ['hqx'],
    'application/mac-compactpro': ['cpt'],
    'application/mads+xml': ['mads'],
    'application/manifest+json': ['webmanifest'],
    'application/marc': ['mrc'],
    'application/marcxml+xml': ['mrcx'],
    'application/mathematica': ['ma', 'nb', 'mb'],
    'application/mathml+xml': ['mathml'],
    'application/mbox': ['mbox'],
    'application/mediaservercontrol+xml': ['mscml'],
    'application/metalink+xml': ['metalink'],
    'application/metalink4+xml': ['meta4'],
    'application/mets+xml': ['mets'],
    'application/mods+xml': ['mods'],
    'application/mp21': ['m21', 'mp21'],
    'application/mp4': ['mp4s', 'm4p'],
    'application/msword': ['doc', 'dot'],
    'application/mxf': ['mxf'],
    'application/octet-stream': [
        'bin',
        'dms',
        'lrf',
        'mar',
        'so',
        'dist',
        'distz',
        'pkg',
        'bpk',
        'dump',
        'elc',
        'deploy',
        'exe',
        'dll',
        'deb',
        'dmg',
        'iso',
        'img',
        'msi',
        'msp',
        'msm',
        'buffer'
    ],
    'application/oda': ['oda'],
    'application/oebps-package+xml': ['opf'],
    'application/ogg': ['ogx'],
    'application/omdoc+xml': ['omdoc'],
    'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
    'application/oxps': ['oxps'],
    'application/patch-ops-error+xml': ['xer'],
    'application/pdf': ['pdf'],
    'application/pgp-encrypted': ['pgp'],
    'application/pgp-signature': ['asc', 'sig'],
    'application/pics-rules': ['prf'],
    'application/pkcs10': ['p10'],
    'application/pkcs7-mime': ['p7m', 'p7c'],
    'application/pkcs7-signature': ['p7s'],
    'application/pkcs8': ['p8'],
    'application/pkix-attr-cert': ['ac'],
    'application/pkix-cert': ['cer'],
    'application/pkix-crl': ['crl'],
    'application/pkix-pkipath': ['pkipath'],
    'application/pkixcmp': ['pki'],
    'application/pls+xml': ['pls'],
    'application/postscript': ['ai', 'eps', 'ps'],
    'application/pskc+xml': ['pskcxml'],
    'application/raml+yaml': ['raml'],
    'application/rdf+xml': ['rdf'],
    'application/reginfo+xml': ['rif'],
    'application/relax-ng-compact-syntax': ['rnc'],
    'application/resource-lists+xml': ['rl'],
    'application/resource-lists-diff+xml': ['rld'],
    'application/rls-services+xml': ['rs'],
    'application/rpki-ghostbusters': ['gbr'],
    'application/rpki-manifest': ['mft'],
    'application/rpki-roa': ['roa'],
    'application/rsd+xml': ['rsd'],
    'application/rss+xml': ['rss'],
    'application/rtf': ['rtf'],
    'application/sbml+xml': ['sbml'],
    'application/scvp-cv-request': ['scq'],
    'application/scvp-cv-response': ['scs'],
    'application/scvp-vp-request': ['spq'],
    'application/scvp-vp-response': ['spp'],
    'application/sdp': ['sdp'],
    'application/set-payment-initiation': ['setpay'],
    'application/set-registration-initiation': ['setreg'],
    'application/shf+xml': ['shf'],
    'application/smil+xml': ['smi', 'smil'],
    'application/sparql-query': ['rq'],
    'application/sparql-results+xml': ['srx'],
    'application/srgs': ['gram'],
    'application/srgs+xml': ['grxml'],
    'application/sru+xml': ['sru'],
    'application/ssdl+xml': ['ssdl'],
    'application/ssml+xml': ['ssml'],
    'application/tei+xml': ['tei', 'teicorpus'],
    'application/thraud+xml': ['tfi'],
    'application/timestamped-data': ['tsd'],
    'application/voicexml+xml': ['vxml'],
    'application/wasm': ['wasm'],
    'application/widget': ['wgt'],
    'application/winhlp': ['hlp'],
    'application/wsdl+xml': ['wsdl'],
    'application/wspolicy+xml': ['wspolicy'],
    'application/xaml+xml': ['xaml'],
    'application/xcap-diff+xml': ['xdf'],
    'application/xenc+xml': ['xenc'],
    'application/xhtml+xml': ['xhtml', 'xht'],
    'application/xml': ['xml', 'xsl', 'xsd', 'rng'],
    'application/xml-dtd': ['dtd'],
    'application/xop+xml': ['xop'],
    'application/xproc+xml': ['xpl'],
    'application/xslt+xml': ['xslt'],
    'application/xspf+xml': ['xspf'],
    'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],
    'application/yang': ['yang'],
    'application/yin+xml': ['yin'],
    'application/zip': ['zip'],
    'audio/3gpp': ['3gpp'],
    'audio/adpcm': ['adp'],
    'audio/basic': ['au', 'snd'],
    'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
    'audio/mp3': ['mp3'],
    'audio/mp4': ['m4a', 'mp4a'],
    'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
    'audio/ogg': ['oga', 'ogg', 'spx'],
    'audio/s3m': ['s3m'],
    'audio/silk': ['sil'],
    'audio/wav': ['wav'],
    'audio/wave': ['wav'],
    'audio/webm': ['weba'],
    'audio/xm': ['xm'],
    'font/collection': ['ttc'],
    'font/otf': ['otf'],
    'font/ttf': ['ttf'],
    'font/woff': ['woff'],
    'font/woff2': ['woff2'],
    'image/apng': ['apng'],
    'image/bmp': ['bmp'],
    'image/cgm': ['cgm'],
    'image/g3fax': ['g3'],
    'image/gif': ['gif'],
    'image/ief': ['ief'],
    'image/jp2': ['jp2', 'jpg2'],
    'image/jpeg': ['jpeg', 'jpg', 'jpe'],
    'image/jpm': ['jpm'],
    'image/jpx': ['jpx', 'jpf'],
    'image/ktx': ['ktx'],
    'image/png': ['png'],
    'image/sgi': ['sgi'],
    'image/svg+xml': ['svg', 'svgz'],
    'image/tiff': ['tiff', 'tif'],
    'image/webp': ['webp'],
    'message/disposition-notification': ['disposition-notification'],
    'message/global': ['u8msg'],
    'message/global-delivery-status': ['u8dsn'],
    'message/global-disposition-notification': ['u8mdn'],
    'message/global-headers': ['u8hdr'],
    'message/rfc822': ['eml', 'mime'],
    'model/gltf+json': ['gltf'],
    'model/gltf-binary': ['glb'],
    'model/iges': ['igs', 'iges'],
    'model/mesh': ['msh', 'mesh', 'silo'],
    'model/vrml': ['wrl', 'vrml'],
    'model/x3d+binary': ['x3db', 'x3dbz'],
    'model/x3d+vrml': ['x3dv', 'x3dvz'],
    'model/x3d+xml': ['x3d', 'x3dz'],
    'text/cache-manifest': ['appcache', 'manifest'],
    'text/calendar': ['ics', 'ifb'],
    'text/coffeescript': ['coffee', 'litcoffee'],
    'text/css': ['css'],
    'text/csv': ['csv'],
    'text/html': ['html', 'htm', 'shtml'],
    'text/jade': ['jade'],
    'text/jsx': ['jsx'],
    'text/less': ['less'],
    'text/markdown': ['markdown', 'md'],
    'text/mathml': ['mml'],
    'text/n3': ['n3'],
    'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
    'text/richtext': ['rtx'],
    'text/rtf': ['rtf'],
    'text/sgml': ['sgml', 'sgm'],
    'text/shex': ['shex'],
    'text/slim': ['slim', 'slm'],
    'text/stylus': ['stylus', 'styl'],
    'text/tab-separated-values': ['tsv'],
    'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],
    'text/turtle': ['ttl'],
    'text/uri-list': ['uri', 'uris', 'urls'],
    'text/vcard': ['vcard'],
    'text/vtt': ['vtt'],
    'text/xml': ['xml'],
    'text/yaml': ['yaml', 'yml'],
    'video/3gpp': ['3gp', '3gpp'],
    'video/3gpp2': ['3g2'],
    'video/h261': ['h261'],
    'video/h263': ['h263'],
    'video/h264': ['h264'],
    'video/jpeg': ['jpgv'],
    'video/jpm': ['jpm', 'jpgm'],
    'video/mj2': ['mj2', 'mjp2'],
    'video/mp2t': ['ts'],
    'video/mp4': ['mp4', 'mp4v', 'mpg4'],
    'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
    'video/ogg': ['ogv'],
    'video/quicktime': ['qt', 'mov'],
    'video/webm': ['webm']
};
const typesMap = {};
const defaultMime = 'application/octet-stream';
Object.keys(types).forEach(mimestr => {
    const item = types[mimestr];
    item.forEach((ext) => {
        typesMap[ext] = mimestr;
    });
});
const resolveMime = (filePath) => {
    const t = filePath.split('.').pop();
    const type = typesMap[t];
    return type ? type : defaultMime;
};
class file {
    static async serve(req, res, pathname, cwd = ".", index = 'index.html') {
        const { text, code, stats, file } = await this.target(pathname, cwd, index);
        if (code !== 200) {
            res.writeHead(code, {
                'Content-Type': 'text/plain',
                'Content-Length': text.length
            });
            return res.end(text);
        }
        const info = this.info(req.headers, stats, file);
        return this.pipe(res, info, file);
    }
    static async target(pathname, cwd = '.', index = 'index.html') {
        let file = path.join(cwd, pathname);
        if (file.endsWith('/')) {
            file = path.join(file, index);
        }
        if (file.endsWith('/')) {
            return { text: '403 forbidden', code: 403 };
        }
        let stats;
        try {
            stats = await fsStat$1(file);
        }
        catch (e) {
            // not exist
            return { text: '404 page not found', code: 404 };
        }
        if (!stats || !stats.isFile()) {
            return { text: '403 forbidden', code: 403 };
        }
        return { code: 200, stats, file };
    }
    static info(headers, stats, file) {
        const mime = resolveMime(file);
        const lastModify = new Date(stats.mtimeMs).toUTCString();
        if (headers['last-modified'] == lastModify) {
            return {
                code: 304,
                meta: {
                    'Last-Modified': lastModify,
                    'Content-Type': mime,
                    'Content-Length': 0
                }
            };
        }
        let matches = headers.range ? headers.range.trim().match(/^bytes=(\d+)-(\d+)?$/) : false;
        if (matches) {
            const start = parseInt(matches[1]);
            const end = matches[2] ? parseInt(matches[2]) : (stats.size - 1);
            const len = end - start + 1;
            return {
                code: 206,
                meta: {
                    'Content-Range': `bytes ${start}-${end}/${stats.size}`,
                    'Accept-Ranges': 'bytes',
                    'Content-Type': mime,
                    'Content-Length': len,
                },
                start,
                end
            };
        }
        return {
            code: 200,
            meta: {
                'Last-Modified': lastModify,
                'Accept-Ranges': 'bytes',
                'Content-Type': mime,
                'Content-Length': stats.size
            }
        };
    }
    static pipe(res, info, file) {
        const { code, meta, start, end } = info;
        res.writeHead(code, meta);
        if (code == 304) {
            return res.end();
        }
        else if (code == 206) {
            return fs.createReadStream(file, { start, end }).pipe(res);
        }
        return fs.createReadStream(file).pipe(res);
    }
}

class route {
    constructor() {
        this.routes = [];
        this.middlewares = [];
    }
    get(path, fn) {
        return this.add(path, fn, ['GET']);
    }
    post(path, fn) {
        return this.add(path, fn, ['POST']);
    }
    put(path, fn) {
        return this.add(path, fn, ['PUT']);
    }
    delete(path, fn) {
        return this.add(path, fn, ['DELETE']);
    }
    head(path, fn) {
        return this.add(path, fn, ['HEAD']);
    }
    patch(path, fn) {
        return this.add(path, fn, ['PATCH']);
    }
    options(path, fn) {
        return this.add(path, fn, ['OPTIONS']);
    }
    add(path, fn, method = ["GET", "POST", "PUT", "DELETE", "HEAD", "PATCH", "OPTIONS"], timeout = 5000) {
        this.routes.push({ method, path, fn, timeout });
        return this;
    }
    use(prefix = '', middleware = null, timeout = 5000, method = ["GET", "POST", "PUT", "DELETE", "HEAD", "PATCH", "OPTIONS"]) {
        let path = prefix;
        let handler = middleware;
        if (!handler) {
            path = false;
            handler = prefix;
        }
        this.middlewares.push({ path, handler, timeout, method });
        return this;
    }
    match(m, uri) {
        for (let i = 0, j = this.routes.length; i < j; i++) {
            const { method, path, fn, timeout } = this.routes[i];
            if (method.includes(m) && (!path || path.test(uri))) {
                return { fn, params: uri.match(path), timeout };
            }
        }
        return false;
    }
    async runRoute(req, res, pathname, query) {
        const m = this.match(req.method, pathname);
        if (!m) {
            return true;
        }
        const { fn, params, timeout } = m;
        req.ctx.params = params;
        return await new Promise(async (resolve, reject) => {
            const t = setTimeout(() => {
                resolve(false);
            }, timeout);
            try {
                await fn(req, res, pathname, query);
            }
            catch (e) {
                reject(e);
            }
            finally {
                resolve(false);
                clearTimeout(t);
            }
        });
    }
    middlewareMatch(m, uri) {
        const middlewares = [];
        for (let i = 0, j = this.middlewares.length; i < j; i++) {
            const { method, handler, path, timeout } = this.middlewares[i];
            if (method.includes(m) && (!path || path.test(uri))) {
                middlewares.push({ timeout, handler, params: uri.match(path) });
            }
        }
        return middlewares;
    }
    async runMiddleWare(req, res, pathname, query) {
        const m = this.middlewareMatch(req.method, pathname);
        req.ctx = {
            params: [],
            run: true,
            middlewares: [],
            routes: []
        };
        for (let i = 0, j = m.length; i < j; i++) {
            const { handler, params, timeout } = m[i];
            const ret = await new Promise(async (resolve, reject) => {
                req.ctx.params = params;
                const t = setTimeout(() => {
                    resolve(false);
                }, timeout);
                const next = () => {
                    clearTimeout(t);
                    resolve(true);
                };
                const stop = () => {
                    clearTimeout(t);
                    resolve(false);
                };
                try {
                    await handler(req, res, next, stop);
                }
                catch (e) {
                    reject(e);
                }
            });
            if (ret === false) {
                return false;
            }
        }
        return true;
    }
}

class servefns extends route {
    constructor() {
        super();
    }
    buildctx(req, res, pathname, query) {
        req.path = pathname;
        req.query = query;
        req.body = this.body(req);
        req.json = this.parseJson(req);
        req.after = (prefix, middleware, timeout = 5000, method = ["GET", "POST", "PUT", "DELETE", "HEAD", "PATCH", "OPTIONS"]) => {
            let path = prefix;
            let handler = middleware;
            if (!handler) {
                path = /^\//;
                handler = prefix;
            }
            req.ctx.middlewares.push({ path, handler, timeout, method });
            return req;
        };
        res.json = this.sendJson(res);
        res.send = this.sendData(res);
        res.file = this.sendFile(req, res);
    }
    body(request) {
        return async (max = 8192) => {
            return await new Promise((resolve, reject) => {
                let buf = [], count = 0;
                request
                    .on('error', reject)
                    .on('aborted', reject)
                    .on('data', (data) => {
                    buf.push(data);
                    count += data.length;
                    if (count > max) {
                        reject('body too large');
                    }
                }).on('end', () => {
                    resolve(Buffer.concat(buf));
                });
            });
        };
    }
    parseJson(request) {
        return async (max = 8192) => {
            const bodyParser = this.body(request);
            const buf = await bodyParser(max);
            return JSON.parse(buf.toString() || '{}');
        };
    }
    sendJson(response) {
        return (data, status = 200) => {
            const str = JSON.stringify(data);
            response.writeHead(status, {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(str, 'utf8')
            });
            return response.end(str);
        };
    }
    sendData(response) {
        return (data, type = 'text/html', status = 200) => {
            response.writeHead(status, {
                'Content-Type': type,
                'Content-Length': Buffer.byteLength(data, 'utf8')
            });
            return response.end(data);
        };
    }
    sendFile(request, response) {
        return (filepath) => {
            return file.serve(request, response, filepath, '.', '');
        };
    }
    static static(dir) {
        return async (request, response, next, stop) => {
            return file.serve(request, response, request.path, dir) && stop();
        };
    }
}

class nodeserve extends servefns {
    constructor() {
        super();
        this.httpser = this.init();
    }
    init() {
        return http.createServer(async (request, response) => {
            const errhandler = (e) => {
                console.error(e);
                if (!response.headersSent) {
                    response.writeHead(500);
                }
                if (!response.finished) {
                    response.end(e.message || e.toString());
                }
            };
            try {
                request.once('error', errhandler);
                response.once('error', errhandler);
                const [pathname, qs] = decodeURI(request.url).split('?');
                const query = querystring.parse(qs);
                this.buildctx(request, response, pathname, query);
                let ret;
                ret = await this.middleware(request, response, pathname, query);
                if (ret) {
                    ret = await this.route(request, response, pathname, query);
                    if (ret) {
                        ret = await this.servestatic(request, response, pathname, query);
                    }
                }
                await this.runAfter(request, response, pathname, query);
            }
            catch (e) {
                errhandler(e);
            }
        });
    }
    listen(...args) {
        return this.httpser.listen(...args);
    }
    async middleware(req, res, pathname, query) {
        const ret = await this.runMiddleWare(req, res, pathname, query);
        return ret && req.ctx.run;
    }
    async route(req, res, pathname, query) {
        const ret = await this.runRoute(req, res, pathname, query);
        return ret && req.ctx.run;
    }
    async servestatic(req, res, pathname, query) {
        return file.serve(req, res, pathname);
    }
    getAfter(middlewareList, m, uri) {
        const middlewares = [];
        for (let i = 0, j = middlewareList.length; i < j; i++) {
            const { method, handler, path, timeout } = middlewareList[i];
            if (method.includes(m) && path.test(uri)) {
                middlewares.push({ timeout, handler, params: uri.match(path) });
            }
        }
        return middlewares;
    }
    async runAfter(req, res, pathname, query) {
        const m = this.getAfter(req.ctx.middlewares, req.method, pathname);
        for (let i = 0, j = m.length; i < j; i++) {
            const { handler, timeout } = m[i];
            const ret = await new Promise(async (resolve, reject) => {
                const t = setTimeout(() => {
                    resolve(false);
                }, timeout);
                const next = () => {
                    clearTimeout(t);
                    resolve(true);
                };
                const stop = () => {
                    clearTimeout(t);
                    resolve(false);
                };
                try {
                    await handler(req, res, next, stop);
                }
                catch (e) {
                    reject(e);
                }
            });
            if (ret === false) {
                return false;
            }
        }
        return true;
    }
}

const maxItem = 1e3;
const caches = new Map();
class default_1 {
    static log(msg) {
        msg = msg.toString();
        if (this.errorlog.length > maxItem) {
            this.errorlog = [];
        }
        var nowDate = new Date();
        msg = nowDate.toLocaleDateString() + ' ' + nowDate.toLocaleTimeString() + ' ' + msg;
        this.errorlog.push(msg);
        console.log(msg);
    }
    static get(k) {
        return caches.get(k);
    }
    static set(k, v) {
        return caches.set(k, v);
    }
}
default_1.errorlog = [];

class compress {
    constructor(opts, pathname, query) {
        this.opts = opts;
        this.pathname = pathname;
        this.query = query;
        this.options = { urlArgs: '', compress: false, env: 'development' };
        this.jopts = { debug: true, clean: false };
        this.options.urlArgs = query.urlArgs ? query.urlArgs.toString() : '';
    }
    // 解析优先级, 配置文件>连字符>less文件查找>静态文件
    async resolveLess() {
        const pathname = this.pathname.replace('.css', '').replace(/^\//, '');
        const css = this.opts.opts.static ? Object.keys(this.opts.opts.static.css) || [] : [];
        const curr = pathname.replace(/.*static\//, '');
        if (css.includes(curr + '.css')) {
            return this.opts.opts.static.css[curr + '.css'].map((item) => path.join(this.opts.dirname, item));
        }
        if (/-/.test(curr)) {
            const dirs = pathname.split('/');
            const segment = dirs.pop();
            return segment
                .split('-')
                .filter((item) => item)
                .map((item) => {
                return path.join(this.opts.dirname, ...dirs, item) + '.less';
            });
        }
        return [path.join(this.opts.dirname, curr) + '.less'];
    }
    async resolveJs() {
        const pathname = this.pathname.replace('.js', '').replace(/^\//, '');
        const js = this.opts.opts.static ? Object.keys(this.opts.opts.static.js) || [] : [];
        const curr = pathname.replace(/.*static\//, '');
        if (js.includes(curr + '.js')) {
            return this.opts.opts.static.js[curr + '.js'].map((item) => path.join(this.opts.dirname, item));
        }
        if (/-/.test(curr)) {
            const dirs = curr.split('/');
            const segment = dirs.pop();
            return segment
                .split('-')
                .filter((item) => item)
                .map((item) => {
                return path.join(this.opts.dirname, ...dirs, item) + '.js';
            });
        }
        return [path.join(this.opts.dirname, curr) + '.js'];
    }
    async less() {
        const files = await this.resolveLess();
        const time = await util.getUpdateTime(files);
        const ret = default_1.get(this.pathname);
        if (ret && ret.time == time && ret.urlArgs == this.options.urlArgs) {
            return { ret, hit: true };
        }
        const r = await this.compileLess(files);
        const res = { css: r, time, urlArgs: this.options.urlArgs };
        default_1.set(this.pathname, res);
        return { ret: res, hit: false };
    }
    async compileLess(files) {
        const lessInput = files
            .map((item) => {
            return '@import "' + item + '";';
        })
            .join('\r\n');
        let { urlArgs, compress, env } = this.options;
        const less = require('less');
        const autoprefix = require('less-plugin-autoprefix');
        const option = {
            plugins: [new autoprefix({ browsers: ['last 5 versions', 'ie > 9', 'Firefox ESR'] })],
            paths: this.opts.dirname,
            urlArgs,
            compress,
            env,
        };
        const ret = await less.render(lessInput, option);
        return ret.css;
    }
    async Js() {
        const files = await this.resolveJs();
        const time = await util.getUpdateTime(files);
        const ret = default_1.get(this.pathname);
        if (ret && ret.time == time) {
            return { ret, hit: true };
        }
        const r = await this.compileJs(files);
        const res = { js: r, time };
        default_1.set(this.pathname, res);
        return { ret: res, hit: false };
    }
    async compileJs(files) {
        let options;
        if (this.jopts.debug) {
            options = {
                mangle: false,
                compress: false,
                ecma: 2016,
                keep_classnames: true,
                keep_fnames: true,
            };
        }
        else {
            options = {
                ecma: 5,
                mangle: true,
                compress: {
                    arguments: true,
                    booleans_as_integers: true,
                    drop_debugger: false,
                    drop_console: false,
                },
            };
            if (this.jopts.clean) {
                options.compress.drop_console = true;
                options.compress.drop_debugger = true;
            }
        }
        const filesMap = await util.getContent(files);
        const terser = require('terser');
        const ret = await new Promise((resolve, reject) => {
            const result = terser.minify(filesMap, options);
            const er = result.error;
            if (er) {
                const s = er.toString();
                const { filename, line, col, pos } = er;
                er.toString = () => {
                    return `${filename}: ${s} on line ${line}, ${col}:${pos}`;
                };
                return reject(er);
            }
            resolve(result);
        });
        return ret.code;
    }
    async compress(cliargs) {
        this.options.env = 'production';
        this.options.compress = !cliargs.debug;
        this.jopts.debug = cliargs.debug;
        this.jopts.clean = cliargs.clean;
        const { css, js } = this.opts.opts.static;
        for (let item in css) {
            const source = css[item];
            const ret = await this.compileLess(source);
            await fsWriteFile(path.join(this.opts.dirname, item), ret);
        }
        for (let item in js) {
            const source = js[item].map((item) => path.join(this.opts.dirname, item));
            const ret = await this.compileJs(source);
            await fsWriteFile(path.join(this.opts.dirname, item), ret);
        }
    }
    async compressLessOrJs(cliargs, less, js) {
        this.options.env = 'production';
        this.options.compress = !cliargs.debug;
        this.jopts.debug = cliargs.debug;
        this.jopts.clean = cliargs.clean;
        if (less.length > 0) {
            const dst = less[0].replace(/\.less$/, '.min.css');
            const ret = await this.compileLess(less);
            await fsWriteFile(dst, ret);
        }
        if (js.length > 0) {
            const dst = js[0].replace(/\.js$/, '.min.js');
            const ret = await this.compileJs(js);
            await fsWriteFile(dst, ret);
        }
    }
}

var utiljs = {
    isFunction(value) {
        return typeof value === 'function';
    },
    isObject(value) {
        return value && typeof value === 'object' && value.constructor === Object;
    },
    unique(arr) {
        return Array.from(new Set(arr));
    },
    getParams(args) {
        const kMap = {
            '-v': 'version',
            '-p': 'port',
            '-o': 'output',
            '-d': 'dir',
            '-q': 'query',
            '--escape': 'escape',
            '--debug': 'debug',
            '--clean': 'clean',
            '--dry': 'dry',
            '--art': 'art',
            '--nogit': 'nogit',
            '--pretty': 'pretty',
            '--lintlast': 'lintlast',
        };
        return this.params(args, kMap);
    },
    params(args, kMap) {
        const ret = {};
        const keys = Object.keys(kMap);
        let key;
        args.forEach((item) => {
            if (keys.includes(item)) {
                if (item.substr(0, 2) == '--') {
                    ret[kMap[item]] = true;
                }
                else {
                    key = kMap[item];
                }
            }
            else if (key && item.toString().charAt(0) != '-') {
                ret[key] = item;
                key = null;
            }
            else {
                key = null;
            }
        });
        return ret;
    },
};

const readFile = util$1.promisify(fs.readFile);
const includefile = /<!--#\s{1,5}include\s{1,5}file="([\w+/.]{3,50})"\s{1,5}-->/g;
class ssi {
    constructor(cwd, pathname, query) {
        this.cwd = cwd;
        this.pathname = pathname;
        this.query = query;
    }
    async html() {
        const main = path.join(this.cwd, this.pathname);
        return await this.parseHtml(main, this.query, this.cwd);
    }
    async parseHtml(file, query, cwd) {
        const resfile = await readFile(file);
        let html = resfile.toString();
        let res, i = 0, filesMap = {};
        const fillContents = async () => {
            let res;
            let fileList = Object.keys(filesMap).filter((item) => {
                return !filesMap[item];
            });
            res = await Promise.all(fileList.map((item) => {
                return readFile(path.join(cwd, item));
            }));
            res.forEach((item, i) => {
                filesMap[fileList[i]] = item.toString();
            });
        };
        while (i < 6) {
            let matches = {};
            while ((res = includefile.exec(html))) {
                const [holder, file] = res;
                matches[holder] = file;
                if (!filesMap[file]) {
                    filesMap[file] = '';
                }
            }
            if (Object.keys(matches).length === 0) {
                // // 主html文件内,没有include语法,模板引擎不用处理了,直接返回
                return html;
            }
            i++;
            if (i > 5) {
                throw new Error('include file too deep');
            }
            await fillContents();
            Object.keys(matches).forEach((item) => {
                const file = matches[item];
                const content = filesMap[file];
                html = html.replace(item, content);
            });
        }
    }
}

class template {
    constructor(opts, cwd, pathname, query) {
        this.opts = opts;
        this.cwd = cwd;
        this.pathname = pathname;
        this.query = query;
    }
    async art() {
        let file = this.pathname;
        if (file.charAt(0) == '/') {
            file = file.substr(1);
        }
        const template = require('art-template');
        const { minimize, escape } = this.query;
        const options = {
            debug: !minimize,
            minimize,
            compileDebug: !minimize,
            escape: escape,
            root: this.cwd,
            cache: false,
        };
        Object.assign(template.defaults, options);
        const dstfile = path.join(this.cwd, file);
        let data = this.query || {};
        const config = this.opts.opts;
        if (config.template && config.template[file]) {
            const v = config.template[file];
            let r = {};
            if (utiljs.isObject(v)) {
                r = v;
            }
            else {
                const datafile = path.join(this.cwd, config.template[file]);
                r = require(datafile);
            }
            data = Object.assign({}, data, r);
        }
        return template(dstfile, Object.keys(data).length > 0 ? data : {});
    }
    async ssi() {
        const s = new ssi(this.cwd, this.pathname, this.query);
        const html = await s.html();
        return html;
    }
}

class server {
    constructor(args, cliargs, cwd) {
        this.args = args;
        this.cliargs = cliargs;
        this.cwd = cwd;
        this.app = new nodeserve();
    }
    async serve() {
        try {
            this.route();
            this.app
                .listen(this.args.port, this.args.host, () => {
                console.info('Server listening on port %d', this.args.port);
            })
                .on('error', (err) => {
                console.error(err.toString());
            });
            this.watch();
        }
        catch (e) {
            console.error(e);
        }
    }
    route() {
        if (this.cliargs.dry) {
            return;
        }
        this.app.get(/^[\w\-/.]+\.css$/, async (req, res, pathname, query) => {
            const ret = await new compress(this.args.staticCfg, pathname, query).less();
            res.setHeader('x-hit', ret.hit ? 1 : 0);
            res.send(ret.ret.css, 'text/css');
        });
        this.app.get(/^[\w\-/.]+\.js$/, async (req, res, pathname, query) => {
            const ret = await new compress(this.args.staticCfg, pathname, query).Js();
            res.setHeader('x-hit', ret.hit ? 1 : 0);
            res.send(ret.ret.js, 'text/javascript');
        });
        this.app.get(/^[\w\-/.]+\.html$/, async (req, res, pathname, query) => {
            const tpl = new template(this.args.staticCfg, this.cwd, pathname, query);
            let ret;
            if (this.cliargs.art) {
                ret = await tpl.art();
            }
            else {
                ret = await tpl.ssi();
            }
            res.send(ret);
        });
    }
    watch() {
        const f = this.args.staticCfg.fpath;
        if (!f) {
            return;
        }
        console.info('load config file ' + f);
        fs.watchFile(f, async () => {
            try {
                delete require.cache[f];
                const c = require(f);
                const newcfg = Object.assign({}, c);
                this.args.staticCfg.opts = newcfg;
                console.info('config reload success ', f);
            }
            catch (e) {
                console.error('config relaod error ', f, e);
            }
        });
    }
}

/* eslint import/no-dynamic-require:0 */

const logger = getLogger({ prefix: 'prettier-eslint' });
const RULE_DISABLED = {};
const RULE_NOT_CONFIGURED = 'RULE_NOT_CONFIGURED';
const ruleValueExists = prettierRuleValue =>
  prettierRuleValue !== RULE_NOT_CONFIGURED &&
  prettierRuleValue !== RULE_DISABLED &&
  typeof prettierRuleValue !== 'undefined';
const OPTION_GETTERS = {
  printWidth: {
    ruleValue: rules => getRuleValue(rules, 'max-len', 'code'),
    ruleValueToPrettierOption: getPrintWidth
  },
  tabWidth: {
    ruleValue: rules => {
      let value = getRuleValue(rules, 'indent');
      if (value === 'tab') {
        value = getRuleValue(rules, 'max-len', 'tabWidth');
      }
      return value;
    },
    ruleValueToPrettierOption: getTabWidth
  },
  singleQuote: {
    ruleValue: rules => getRuleValue(rules, 'quotes'),
    ruleValueToPrettierOption: getSingleQuote
  },
  trailingComma: {
    ruleValue: rules => getRuleValue(rules, 'comma-dangle', []),
    ruleValueToPrettierOption: getTrailingComma
  },
  bracketSpacing: {
    ruleValue: rules => getRuleValue(rules, 'object-curly-spacing'),
    ruleValueToPrettierOption: getBracketSpacing
  },
  semi: {
    ruleValue: rules => getRuleValue(rules, 'semi'),
    ruleValueToPrettierOption: getSemi
  },
  useTabs: {
    ruleValue: rules => getRuleValue(rules, 'indent'),
    ruleValueToPrettierOption: getUseTabs
  },
  jsxBracketSameLine: {
    ruleValue: rules =>
      getRuleValue(rules, 'react/jsx-closing-bracket-location', 'nonEmpty'),
    ruleValueToPrettierOption: getJsxBracketSameLine
  },
  arrowParens: {
    ruleValue: rules => getRuleValue(rules, 'arrow-parens'),
    ruleValueToPrettierOption: getArrowParens
  }
};

function getOptionsForFormatting(
  eslintConfig,
  prettierOptions = {},
  fallbackPrettierOptions = {},
  eslintPath,
  exitOnLintErr
) {
  const eslint = getRelevantESLintConfig(eslintConfig, eslintPath,exitOnLintErr);
  const prettier = getPrettierOptionsFromESLintRules(
    eslintConfig,
    prettierOptions,
    fallbackPrettierOptions
  );
  return { eslint, prettier };
}

function getRelevantESLintConfig(eslintConfig, eslintPath, exitOnLintErr) {
  const cliEngine = getESLintCLIEngine(eslintPath);
  // TODO: Actually test this branch
  // istanbul ignore next
  const loadedRules =
    (cliEngine.getRules && cliEngine.getRules()) ||
    // XXX: Fallback list of unfixable rules, when using and old version of eslint
    new Map([['global-require', { meta: {} }], ['no-with', { meta: {} }]]);

  const { rules } = eslintConfig;

  logger.debug('turning off unfixable rules');

  const relevantRules = exitOnLintErr ? rules : Object.entries(rules).reduce(
    (rulesAccumulator, [name, rule]) => {
      if (loadedRules.has(name)) {
        const {
          meta: { fixable }
        } = loadedRules.get(name);

        if (!fixable) {
          logger.trace('turing off rule:', JSON.stringify({ [name]: rule }));
          rule = ['off'];
        }
      }

      rulesAccumulator[name] = rule;
      return rulesAccumulator;
    },
    {}
  );

  return {
    // defaults
    useEslintrc: false,
    baseConfig: {
      settings: eslintConfig.settings || {}
    },
    ...eslintConfig,
    // overrides
    rules: relevantRules,
    fix: true,
    globals: []
  };
}

/**
 * This accepts an eslintConfig object and converts
 * it to the `prettier` options object
 */
function getPrettierOptionsFromESLintRules(
  eslintConfig,
  prettierOptions,
  fallbackPrettierOptions
) {
  const { rules } = eslintConfig;

  const prettierPluginOptions = getRuleValue(rules, 'prettier/prettier', []);

  if (ruleValueExists(prettierPluginOptions)) {
    prettierOptions = { ...prettierPluginOptions, ...prettierOptions };
  }

  return Object.keys(OPTION_GETTERS).reduce(
    (options, key) =>
      configureOptions(
        prettierOptions,
        fallbackPrettierOptions,
        key,
        options,
        rules
      ),
    prettierOptions
  );
}

// If an ESLint rule that prettier can be configured with is enabled create a
// prettier configuration object that reflects the ESLint rule configuration.
function configureOptions(
  prettierOptions,
  fallbackPrettierOptions,
  key,
  options,
  rules
) {
  const givenOption = prettierOptions[key];
  const optionIsGiven = givenOption !== undefined;

  if (optionIsGiven) {
    options[key] = givenOption;
  } else {
    const { ruleValue, ruleValueToPrettierOption } = OPTION_GETTERS[key];
    const eslintRuleValue = ruleValue(rules);

    const option = ruleValueToPrettierOption(
      eslintRuleValue,
      fallbackPrettierOptions,
      rules
    );

    if (option !== undefined) {
      options[key] = option;
    }
  }

  return options;
}

function getPrintWidth(eslintValue, fallbacks) {
  return makePrettierOption('printWidth', eslintValue, fallbacks);
}

function getTabWidth(eslintValue, fallbacks) {
  return makePrettierOption('tabWidth', eslintValue, fallbacks);
}

function getSingleQuote(eslintValue, fallbacks) {
  let prettierValue;

  if (eslintValue === 'single') {
    prettierValue = true;
  } else if (eslintValue === 'double') {
    prettierValue = false;
  } else if (eslintValue === 'backtick') {
    prettierValue = false;
  } else {
    prettierValue = eslintValue;
  }

  return makePrettierOption('singleQuote', prettierValue, fallbacks);
}

function getTrailingComma(eslintValue, fallbacks) {
  let prettierValue;

  if (eslintValue === 'never') {
    prettierValue = 'none';
  } else if (
    typeof eslintValue === 'string' &&
    eslintValue.indexOf('always') === 0
  ) {
    prettierValue = 'es5';
  } else if (typeof eslintValue === 'object') {
    prettierValue = getValFromTrailingCommaConfig(eslintValue);
  } else {
    prettierValue = RULE_NOT_CONFIGURED;
  }

  return makePrettierOption('trailingComma', prettierValue, fallbacks);
}

function getValFromTrailingCommaConfig(objectConfig) {
  const { arrays = '', objects = '', functions = '' } = objectConfig;
  const fns = isAlways(functions);
  const es5 = [arrays, objects].some(isAlways);

  if (fns) {
    return 'all';
  } else if (es5) {
    return 'es5';
  } else {
    return 'none';
  }
}

function getBracketSpacing(eslintValue, fallbacks) {
  let prettierValue;

  if (eslintValue === 'never') {
    prettierValue = false;
  } else if (eslintValue === 'always') {
    prettierValue = true;
  } else {
    prettierValue = eslintValue;
  }

  return makePrettierOption('bracketSpacing', prettierValue, fallbacks);
}

function getSemi(eslintValue, fallbacks) {
  let prettierValue;

  if (eslintValue === 'never') {
    prettierValue = false;
  } else if (eslintValue === 'always') {
    prettierValue = true;
  } else {
    prettierValue = eslintValue;
  }

  return makePrettierOption('semi', prettierValue, fallbacks);
}

function getUseTabs(eslintValue, fallbacks) {
  let prettierValue;

  if (eslintValue === 'tab') {
    prettierValue = true;
  } else {
    prettierValue = RULE_NOT_CONFIGURED;
  }

  return makePrettierOption('useTabs', prettierValue, fallbacks);
}

function getJsxBracketSameLine(eslintValue, fallbacks) {
  let prettierValue;

  if (eslintValue === 'after-props') {
    prettierValue = true;
  } else if (
    eslintValue === 'tag-aligned' ||
    eslintValue === 'line-aligned' ||
    eslintValue === 'props-aligned'
  ) {
    prettierValue = false;
  } else {
    prettierValue = eslintValue;
  }

  return makePrettierOption('jsxBracketSameLine', prettierValue, fallbacks);
}

function getArrowParens(eslintValue, fallbacks) {
  let prettierValue;

  if (eslintValue === 'as-needed') {
    prettierValue = 'avoid';
  } else {
    prettierValue = eslintValue;
  }

  return makePrettierOption('arrowParens', prettierValue, fallbacks);
}

function extractRuleValue(objPath, name, value) {
  // XXX: Ignore code coverage for the following else case
  // There are currently no eslint rules which we can infer prettier
  // options from, that have an object option which we don't know how
  // to infer from.

  // istanbul ignore else
  if (objPath) {
    logger.trace(
      commonTags.oneLine`
        Getting the value from object configuration of ${name}.
        delving into ${JSON.stringify(value)} with path "${objPath}"
      `
    );

    return delve(value, objPath, RULE_NOT_CONFIGURED);
  }

  // istanbul ignore next
  logger.debug(
    commonTags.oneLine`
      The ${name} rule is using an object configuration
      of ${JSON.stringify(value)} but prettier-eslint is
      not currently capable of getting the prettier value
      based on an object configuration for ${name}.
      Please file an issue (and make a pull request?)
    `
  );

  // istanbul ignore next
  return undefined;
}

function getRuleValue(rules, name, objPath) {
  const ruleConfig = rules[name];

  if (Array.isArray(ruleConfig)) {
    const [ruleSetting, value] = ruleConfig;

    // If `ruleSetting` is set to disable the ESLint rule don't use `value` as
    // it might be a value provided by an overriden config package e.g. airbnb
    // overriden by config-prettier. The airbnb values are provided even though
    // config-prettier disables the rule. Instead use fallback or prettier
    // default.
    if (ruleSetting === 0 || ruleSetting === 'off') {
      return RULE_DISABLED;
    }

    if (typeof value === 'object') {
      return extractRuleValue(objPath, name, value);
    } else {
      logger.trace(
        commonTags.oneLine`
          The ${name} rule is configured with a
          non-object value of ${value}. Using that value.
        `
      );
      return value;
    }
  }

  return RULE_NOT_CONFIGURED;
}

function isAlways(val) {
  return val.indexOf('always') === 0;
}

function makePrettierOption(prettierRuleName, prettierRuleValue, fallbacks) {
  if (ruleValueExists(prettierRuleValue)) {
    return prettierRuleValue;
  }

  const fallback = fallbacks[prettierRuleName];
  if (typeof fallback !== 'undefined') {
    logger.debug(
      commonTags.oneLine`
        The ${prettierRuleName} rule is not configured,
        using provided fallback of ${fallback}
      `
    );
    return fallback;
  }

  logger.debug(
    commonTags.oneLine`
      The ${prettierRuleName} rule is not configured,
      let prettier decide
    `
  );
  return undefined;
}

function requireModule(modulePath, name) {
  try {
    logger.trace(`requiring "${name}" module at "${modulePath}"`);
    return require(modulePath);
  } catch (error) {
    logger.error(
      commonTags.oneLine`
      There was trouble getting "${name}".
      Is "${modulePath}" a correct path to the "${name}" module?
    `
    );
    throw error;
  }
}

function getESLintCLIEngine(eslintPath, eslintOptions) {
  const { CLIEngine } = requireModule(eslintPath, 'eslint');
  try {
    return new CLIEngine(eslintOptions);
  } catch (error) {
    logger.error(`There was trouble creating the ESLint CLIEngine.`);
    throw error;
  }
}

/* eslint no-console:0, global-require:0, import/no-dynamic-require:0 */
const logger$1 = getLogger({ prefix: 'prettier-eslint' });

/**
 * Formats the text with prettier and then eslint based on the given options
 * @param {String} options.filePath - the path of the file being formatted
 *  can be used in leu of `eslintConfig` (eslint will be used to find the
 *  relevant config for the file). Will also be used to load the `text` if
 *  `text` is not provided.
 * @param {String} options.text - the text (JavaScript code) to format
 * @param {String} options.eslintPath - the path to the eslint module to use.
 *   Will default to require.resolve('eslint')
 * @param {String} options.prettierPath - the path to the prettier module.
 *   Will default to require.resovlve('prettier')
 * @param {Object} options.eslintConfig - the config to use for formatting
 *  with ESLint.
 * @param {Object} options.prettierOptions - the options to pass for
 *  formatting with `prettier`. If not provided, prettier-eslint will attempt
 *  to create the options based on the eslintConfig
 * @param {Object} options.fallbackPrettierOptions - the options to pass for
 *  formatting with `prettier` if the given option is not inferrable from the
 *  eslintConfig.
 * @param {String} options.logLevel - the level for the logs
 *  (error, warn, info, debug, trace)
 * @param {Boolean} options.prettierLast - Run Prettier Last
 * @param {Boolean} options.exitOnLintErr - exit on lint error and report lint errors and warnings
 * @return {String} - the formatted string
 */
async function format(options) {
  const { logLevel = getDefaultLogLevel() } = options;
  logger$1.setLevel(logLevel);
  logger$1.trace('called format with options:', prettyFormat(options));

  const {
    filePath,
    text = getTextFromFilePath(filePath),
    eslintPath = getModulePath(filePath, 'eslint'),
    prettierPath = getModulePath(filePath, 'prettier'),
    prettierLast,
    fallbackPrettierOptions
  } = options;

  const eslintConfig = merge(
    {},
    options.eslintConfig,
    getESLintConfig(filePath, eslintPath)
  );

  if (typeof eslintConfig.globals === 'object') {
    eslintConfig.globals = Object.entries(eslintConfig.globals).map(
      ([key, value]) => `${key}:${value}`
    );
  }

  const prettierOptions = merge(
    {},
    filePath && { filepath: filePath },
    getPrettierConfig(filePath, prettierPath),
    options.prettierOptions
  );

  const formattingOptions = getOptionsForFormatting(
    eslintConfig,
    prettierOptions,
    fallbackPrettierOptions,
    eslintPath,
    options.exitOnLintErr
  );

  logger$1.debug(
    'inferred options:',
    prettyFormat({
      filePath,
      text,
      eslintPath,
      prettierPath,
      eslintConfig: formattingOptions.eslint,
      prettierOptions: formattingOptions.prettier,
      logLevel,
      prettierLast
    })
  );

  const eslintExtensions = eslintConfig.extensions || [
    '.js',
    '.jsx',
    '.ts',
    '.tsx',
    '.mjs',
    '.vue'
  ];
  const fileExtension = path__default.extname(filePath || '');

  // If we don't get filePath run eslint on text, otherwise only run eslint
  // if it's a configured extension or fall back to a "supported" file type.
  const onlyPrettier = filePath
    ? !eslintExtensions.includes(fileExtension)
    : false;

  const prettify = createPrettify(formattingOptions.prettier, prettierPath);

  if (onlyPrettier) {
    return prettify(text);
  }

  if (['.ts', '.tsx'].includes(fileExtension)) {
    formattingOptions.eslint.parser = require.resolve('@typescript-eslint/parser');
    for (const k in formattingOptions.eslint.rules) {
      if (k.includes('vue/')) {
        formattingOptions.eslint.rules[k] = ['off'];
      }
    }
  }

  if (['.vue'].includes(fileExtension)) {
    formattingOptions.eslint.parser = require.resolve('vue-eslint-parser');
  }

  const eslintFix = createEslintFix(formattingOptions.eslint, eslintPath, options.exitOnLintErr);

  if (prettierLast) {
    return prettify(await eslintFix(text, filePath));
  }
  return await eslintFix(prettify(text), filePath);
}

function createPrettify(formatOptions, prettierPath) {
  return function prettify(text) {
    logger$1.debug('calling prettier on text');
    logger$1.trace(
      commonTags.stripIndent`
      prettier input:

      ${indentString(text, 2)}
    `
    );
    const prettier = requireModule(prettierPath, 'prettier');
    try {
      logger$1.trace(`calling prettier.format with the text and prettierOptions`);
      const output = prettier.format(text, formatOptions);
      logger$1.trace('prettier: output === input', output === text);
      logger$1.trace(
        commonTags.stripIndent`
        prettier output:

        ${indentString(output, 2)}
      `
      );
      return output;
    } catch (error) {
      logger$1.error('prettier formatting failed due to a prettier error');
      throw error;
    }
  };
}

function createEslintFix(eslintConfig, eslintPath, exitOnLintErr) {
  return async function eslintFix(text, filePath) {
    const cliEngine = getESLintCLIEngine(eslintPath, eslintConfig);
    try {
      logger$1.trace(`calling cliEngine.executeOnText with the text`);
      const report = cliEngine.executeOnText(text, filePath, true);
      logger$1.trace(
        `executeOnText returned the following report:`,
        prettyFormat(report)
      );
      // default the output to text because if there's nothing
      // to fix, eslint doesn't provide `output`
      const [{ output = text, errorCount }] = report.results;
      if (exitOnLintErr) {
        const formatter = await cliEngine.getFormatter('stylish');
        const output = await formatter(report.results);
        if (output) {
          console.info(output);
          if (errorCount > 0) {
            process.exit(1);
          }
        }
      }
      logger$1.trace('eslint --fix: output === input', output === text);
      // NOTE: We're ignoring linting errors/warnings here and
      // defaulting to the given text if there are any
      // because all we're trying to do is fix what we can.
      // We don't care about what we can't
      logger$1.trace(
        commonTags.stripIndent`
        eslint --fix output:

        ${indentString(output, 2)}
      `
      );
      return output;
    } catch (error) {
      logger$1.error('eslint fix failed due to an eslint error');
      throw error;
    }
  };
}

function getTextFromFilePath(filePath) {
  try {
    logger$1.trace(
      commonTags.oneLine`
        attempting fs.readFileSync to get
        the text for file at "${filePath}"
      `
    );
    return fs__default.readFileSync(filePath, 'utf8');
  } catch (error) {
    logger$1.error(
      commonTags.oneLine`
        failed to get the text to format
        from the given filePath: "${filePath}"
      `
    );
    throw error;
  }
}

function getESLintConfig(filePath, eslintPath) {
  const eslintOptions = {};
  if (filePath) {
    eslintOptions.cwd = path__default.dirname(filePath);
  }
  logger$1.trace(
    commonTags.oneLine`
      creating ESLint CLI Engine to get the config for
      "${filePath || process.cwd()}"
    `
  );
  const cliEngine = getESLintCLIEngine(eslintPath, eslintOptions);
  try {
    logger$1.debug(`getting eslint config for file at "${filePath}"`);
    const config = cliEngine.getConfigForFile(filePath);
    logger$1.trace(
      `eslint config for "${filePath}" received`,
      prettyFormat(config)
    );
    return {
      ...eslintOptions,
      ...config
    };
  } catch (error) {
    // is this noisy? Try setting options.disableLog to false
    logger$1.debug('Unable to find config');
    return { rules: {} };
  }
}

function getPrettierConfig(filePath, prettierPath) {
  const prettier = requireModule(prettierPath, 'prettier');
  return (
    (prettier.resolveConfig &&
      prettier.resolveConfig.sync &&
      prettier.resolveConfig.sync(filePath)) ||
    {}
  );
}

function getModulePath(filePath = __filename, moduleName) {
  try {
    return requireRelative.resolve(moduleName, filePath);
  } catch (error) {
    logger$1.debug(
      commonTags.oneLine`
        There was a problem finding the ${moduleName}
        module. Using prettier-eslint's version.
      `,
      error.message,
      error.stack
    );
    return require.resolve(moduleName);
  }
}

function getDefaultLogLevel() {
  return process.env.LOG_LEVEL || 'warn';
}

const spawn = util$1.promisify(child_process.spawn);
const spawnSync = child_process.spawnSync;
const prettyTypes = ['js', 'vue', 'jsx', 'ts', 'css', 'less', 'html', 'json', 'scss', 'md'];
const extParser = {
    js: 'babel',
    mjs: 'babel',
    jsx: 'babel',
    ts: 'typescript',
    vue: 'vue',
    html: 'html',
    css: 'css',
    less: 'less',
    scss: 'scss',
    json: 'json',
    md: 'mdx',
    yaml: 'yaml',
};
const lintParser = {
    js: 'babel-eslint',
    mjs: 'babel-eslint',
    vue: 'vue-eslint-parser',
    ts: '@typescript-eslint/parser',
    tsx: '@typescript-eslint/parser',
};
// see https://github.com/eslint/eslint/blob/master/conf/eslint-recommended.js
const rules = {
    'constructor-super': 'error',
    'for-direction': 'error',
    'getter-return': 'error',
    'no-async-promise-executor': 'error',
    'no-case-declarations': 'error',
    'no-class-assign': 'error',
    'no-compare-neg-zero': 'error',
    'no-cond-assign': 'error',
    'no-const-assign': 'error',
    'no-constant-condition': 'error',
    'no-control-regex': 'error',
    'no-debugger': 'error',
    'no-delete-var': 'error',
    'no-dupe-args': 'error',
    'no-dupe-class-members': 'error',
    'no-dupe-else-if': 'error',
    'no-dupe-keys': 'error',
    'no-duplicate-case': 'error',
    'no-empty': 'error',
    'no-empty-character-class': 'error',
    'no-empty-pattern': 'error',
    'no-ex-assign': 'error',
    'no-extra-boolean-cast': 'error',
    'no-extra-semi': 'error',
    'no-fallthrough': 'error',
    'no-func-assign': 'error',
    'no-global-assign': 'error',
    'no-import-assign': 'error',
    'no-inner-declarations': 'error',
    'no-invalid-regexp': 'error',
    'no-irregular-whitespace': 'error',
    'no-misleading-character-class': 'error',
    'no-mixed-spaces-and-tabs': 'warn',
    'no-new-symbol': 'error',
    'no-obj-calls': 'error',
    'no-octal': 'error',
    'no-prototype-builtins': 'error',
    'no-redeclare': 'error',
    'no-regex-spaces': 'error',
    'no-self-assign': 'error',
    'no-setter-return': 'error',
    'no-shadow-restricted-names': 'error',
    'no-sparse-arrays': 'error',
    'no-this-before-super': 'error',
    'no-undef': 'error',
    'no-unexpected-multiline': 'error',
    'no-unreachable': 'error',
    'no-unsafe-finally': 'error',
    'no-unsafe-negation': 'error',
    'no-unused-labels': 'error',
    'no-unused-vars': 'warn',
    'no-useless-catch': 'error',
    'no-useless-escape': 'error',
    'no-with': 'error',
    'require-yield': 'error',
    'use-isnan': 'error',
    'valid-typeof': 'error',
};
const config = {
    eslintConfig: {
        env: {
            browser: true,
            es6: true,
            node: true,
        },
        parserOptions: {
            ecmaVersion: 7,
            sourceType: 'module',
        },
        extends: ['plugin:vue/recommended', 'eslint:recommended'],
        plugins: ['vue'],
        parser: '',
        rules,
        useEslintrc: true,
        reportUnusedDisableDirectives: true,
    },
    prettierOptions: {
        printWidth: 120,
        tabWidth: 4,
        singleQuote: true,
        useTabs: true,
        semi: true,
        trailingComma: 'es5',
        bracketSpacing: true,
        arrowParens: 'always',
        endOfLine: 'lf',
        parser: 'babel',
        jsxBracketSameLine: false,
    },
    fallbackPrettierOptions: {
        printWidth: 120,
        tabWidth: 4,
        singleQuote: true,
        useTabs: true,
        semi: true,
        trailingComma: 'es5',
        bracketSpacing: true,
        arrowParens: 'always',
        endOfLine: 'lf',
        parser: 'babel',
        jsxBracketSameLine: false,
    },
    prettierLast: true,
    exitOnLintErr: true,
};
const options = {
    dir: 'config',
    git: '.git',
    hooks: 'hooks',
    precommit: 'pre-commit',
    postcommit: 'post-commit',
    commitmsg: 'commit-msg',
};
const stat = fs.constants.R_OK | fs.constants.W_OK;
const spawnOps = { stdio: 'inherit', shell: true };
class lint {
    constructor(cwd, files, opts) {
        this.cwd = cwd;
        this.opts = opts;
        this.files = [];
        this.files = files.filter((item) => item.charAt(0) != '-');
        if (this.opts.pretty) {
            config.exitOnLintErr = false;
        }
        if (this.opts.lintlast) {
            config.prettierLast = false;
        }
    }
    async gitlint() {
        if (this.files.length < 1) {
            return;
        }
        const { prefiles, gitfiles } = this.parse(this.files);
        await this.dolint(prefiles, gitfiles);
        if (!this.opts.nogit) {
            await this.gitadd(gitfiles);
        }
    }
    parse(files) {
        const prefiles = [];
        const gitfiles = [];
        const filetypes = files.map((item) => {
            const name = item.trim();
            const type = item.split('.').pop();
            let p = name;
            if (!path.isAbsolute(name)) {
                p = path.join(this.cwd, name);
            }
            if (prettyTypes.includes(type)) {
                prefiles.push(p);
            }
            gitfiles.push(p);
            return { name, path: p, type };
        });
        return { prefiles, gitfiles, filetypes };
    }
    autofiles() {
        const res = spawnSync('git', ['diff', '--name-only', '--diff-filter=ACM']);
        const arrs = res.stdout
            .toString()
            .split('\n')
            .filter((v) => v);
        return arrs;
    }
    async lint() {
        if (this.files.length < 1) {
            this.files = this.autofiles();
        }
        if (this.files.length < 1) {
            return;
        }
        const { prefiles, gitfiles } = this.parse(this.files);
        await this.dolint(prefiles, gitfiles);
    }
    async dolint(prefiles, gitfiles) {
        await this.checkfiles(gitfiles);
        await Promise.all(this.lintConfig(prefiles));
    }
    lintConfig(prefiles) {
        return prefiles.map((item) => {
            return (async () => {
                const r = await fsReadFile(item, 'utf-8');
                if (!r || r.trim().length < 1) {
                    return true;
                }
                const options = {
                    ...config,
                    ...{
                        filePath: item,
                    },
                    ...{
                        text: r,
                    },
                };
                const [esparser, preparser, ext] = this.getParser(item);
                options.eslintConfig.parser = esparser;
                options.prettierOptions.parser = preparser;
                options.fallbackPrettierOptions.parser = preparser;
                if (['ts', 'tsx'].includes(ext)) {
                    options.eslintConfig.extends = options.eslintConfig.extends.filter((item) => !item.includes('vue'));
                    options.eslintConfig.plugins = options.eslintConfig.plugins.filter((item) => !item.includes('vue'));
                }
                const res = await format(options);
                if (r !== res && res) {
                    // 异步写文件,其他异步终止进程,容易写出空文件
                    fs.writeFileSync(item, res);
                }
                console.log(item.replace(this.cwd + '/', ''));
            })();
        });
    }
    getParser(file) {
        const ext = file
            .split('.')
            .pop()
            .toLowerCase();
        return [lintParser[ext] ? lintParser[ext] : '', extParser[ext] ? extParser[ext] : 'babel', ext];
    }
    gitadd(f) {
        if (f && f.length) {
            return spawn('git', ['add', '-u', f.join(' ')], spawnOps);
        }
        return Promise.resolve();
    }
    async install() {
        const { git, cwd, hooks, precommit, postcommit, commitmsg } = Object.assign({}, options, this.opts);
        const dir = this.opts.dir ? '' : options.dir;
        const prehook = path.join(this.cwd, dir, precommit);
        const posthook = path.join(this.cwd, dir, postcommit);
        const msghook = path.join(this.cwd, dir, commitmsg);
        const predst = path.join(cwd, git, hooks, precommit);
        const postdst = path.join(cwd, git, hooks, postcommit);
        const msgdst = path.join(cwd, git, hooks, commitmsg);
        const mode = 0o755;
        await Promise.all([fsAccess(prehook, stat), fsAccess(posthook, stat), fsAccess(msghook, stat)]);
        await Promise.all([fsCopyFile(prehook, predst), fsCopyFile(posthook, postdst), fsCopyFile(msghook, msgdst)]);
        await Promise.all([fsChmod(predst, mode), fsChmod(postdst, mode), fsChmod(msgdst, mode)]);
    }
    async checkfiles(files) {
        const maxsize = 1048576;
        // 检查文件大小,超过1MB禁止提交
        const stats = await Promise.all(files.map((item) => fsStat(item)));
        return stats.every((item, index) => {
            if (item.size > maxsize) {
                throw new Error(`${files[index]} too large,${item.size} exceed ${maxsize}`);
            }
            return true;
        });
    }
    static async commitlint(commitfile) {
        const str = await fsReadFile(commitfile);
        const msg = str.toString();
        if (/Merge\s+branch/i.test(msg)) {
            return;
        }
        if (!/(build|ci|docs|feat|fix|perf|refactor|style|test|revert|chore).{0,2}(\(.{1,100}\))?.{0,2}:.{1,200}/.test(msg)) {
            console.info('commit message should be format like <type>(optional scope): <description>');
            process$1.exit(1);
        }
    }
}

var help = `
Usage:
    air [command] [flag]
Commands:
    serve           start air http server
    lint            eslint js
    gitlint         lint used for git hook
    compress        compress less or javascript files
    install         install git hooks
    template        use art-template render html
    
Flags:
    -v              show air version
    -h              show this help information
    -p              set server listen port
    -d              document root , work dir, install dir
    -o              set output file path for air template
    -q              urlArgs params in less render
    --debug         compress with debug mode
    --clean         compress with clean mode,remove console debugger
    --escape        escape when use art-template
    --pretty        pretty and lint-fixable-only for gitlint and lint
    --lintlast      do pretty first and then do eslint
    --nogit         do not integrate with git for gitlint
    --dry           just run as a static server
    --art           use art-template instead of ssi
`;
const version = '0.7.4';
const templatetips = `
Usage:
    air template filename.html [flag]

Flags:
    -o              set output file path for air template
    -d              work dir for air template
    --debug         compress with debug mode
    --escape        escape when use template
    --art           use art-template instead of ssi

`;

class command {
    /**
     * air lint --pretty
     * air lint --lintlast
     * @param args
     * @param cwd
     * @param opts
     * @param staticCfg
     */
    static async lint(args, cwd, opts, staticCfg) {
        await new lint(cwd, args, opts).lint();
    }
    /**
     * air gitlint --pretty
     * air gitlint --lintlast
     * air gitlint --nogit
     * @param args
     * @param cwd
     * @param opts
     * @param staticCfg
     */
    static async gitlint(args, cwd, opts, staticCfg) {
        await new lint(cwd, args, opts).gitlint();
    }
    static async commitlint(args, cwd, opts, staticCfg) {
        await lint.commitlint(args[0]);
    }
    /**
     * air install -dir path/to/dir
     * @param args
     * @param cwd
     * @param opts
     */
    static async install(args, cwd, opts, staticCfg) {
        await new lint(cwd, args, opts).install();
    }
    /**
     * air compress --clean
     * air compress --debug
     * air compress style.less other.less -q urlargs
     * air compress style.less other.less some.js --clean/debug
     * @param args
     * @param cwd
     * @param opts
     */
    static async compress(args, cwd, opts, staticCfg) {
        let less = [];
        let js = [];
        args.forEach((item) => {
            if (item.charAt(0) !== '-') {
                const ext = item.split('.').pop();
                if (ext == 'js') {
                    js.push(item);
                }
                else if (ext == 'less') {
                    less.push(item);
                }
            }
        });
        if (less.length > 0 || js.length > 0) {
            return await new compress(staticCfg, '', {}).compressLessOrJs(opts, less, js);
        }
        if (!staticCfg.fpath) {
            console.log('no config found');
            return;
        }
        await new compress(staticCfg, '', { urlArgs: opts.query }).compress(opts);
    }
    /**
     *
     * air template --escape
     * air template --debug
     * @param filename
     * @param data
     * @param options
     */
    static async template(args, cwd, opts, staticCfg) {
        const file = args.filter((item) => item.charAt(0) !== '-')[0];
        if (!file) {
            throw new Error(templatetips);
        }
        const query = { minimize: true, escape: false };
        if (opts.debug) {
            query.minimize = false;
        }
        if (opts.escape) {
            query.escape = true;
        }
        const tpl = new template(staticCfg, cwd, file, query);
        let res;
        if (opts.art) {
            res = await tpl.art();
        }
        else {
            res = await tpl.ssi();
        }
        if (opts.output) {
            return await fsWriteFile(opts.output, res);
        }
        process.stdout.write(res);
    }
}

class cli {
    constructor(cwd) {
        this.cwd = cwd;
        this.opts = {
            host: '0.0.0.0',
            port: 8088,
            staticCfg: {
                fpath: '',
                dirname: '',
                opts: {
                    static: {
                        css: null,
                        js: null,
                    },
                    template: {},
                },
            },
        };
    }
    async run(argv) {
        try {
            const [, , ...args] = argv;
            this.argv = args;
            this.args = utiljs.getParams(args);
            this.args.cwd = this.cwd;
            this.opts.port = this.args.port || 8088;
            if (this.args.dir) {
                process.chdir(this.args.dir);
            }
            this.cwd = process.cwd();
            await this.loadConfig();
            if (args.length > 0) {
                await this.runArgs();
            }
            else {
                await this.runInit();
            }
        }
        catch (e) {
            console.error(e.stack || e.message || e);
            process.exit(1);
        }
    }
    async loadConfig() {
        const { json, fpath, dirname } = await util.getConfig(this.cwd);
        this.opts.staticCfg.opts = json;
        this.opts.staticCfg.fpath = fpath;
        this.opts.staticCfg.dirname = dirname;
    }
    /**
    
     * air compress
     * air lint
     * air template
     *
     * air install
     * air gitlint
     * air commitlint
     */
    async runArgs() {
        const [m, ...args] = this.argv;
        const f = command[m];
        if (utiljs.isFunction(f)) {
            return await f.call(command, args, this.cwd, this.args, this.opts.staticCfg);
        }
        return await this.fallback(m, args);
    }
    /**
     * air -p
     * air -d
     * air --dry
     * air --art
     *
     */
    async runInit() {
        return new server(this.opts, this.args, this.cwd).serve();
    }
    /**
     *
     * parse flag
     *
     * air -v
     * air -h
     * air serve
     *
     */
    async fallback(m, args) {
        if (['-v'].includes(m) || args.includes('-v')) {
            this.version();
        }
        else if (['serve', '-p', '-d', '--dry', '--art'].includes(m)) {
            await this.runInit();
        }
        else if (this.args.help) {
            this.help();
        }
        else {
            this.help();
        }
    }
    version() {
        console.log('air version: air/' + version);
    }
    help() {
        console.info(help);
    }
}

new cli(process$1.cwd()).run(process$1.argv);
