#!/usr/bin/env node
'use strict';

var process$1 = require('process');
var fs = require('fs');
var path = require('path');
var util$1 = require('util');
var http = require('http');
var querystring = require('querystring');
var child_process = require('child_process');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var process__namespace = /*#__PURE__*/_interopNamespace(process$1);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var http__namespace = /*#__PURE__*/_interopNamespace(http);
var querystring__namespace = /*#__PURE__*/_interopNamespace(querystring);
var child_process__namespace = /*#__PURE__*/_interopNamespace(child_process);

const fsStat$1 = util$1.promisify(fs__namespace.stat);
const fsAccess = util$1.promisify(fs__namespace.access);
const fsWriteFile = util$1.promisify(fs__namespace.writeFile);
const fsReadFile = util$1.promisify(fs__namespace.readFile);
const fsCopyFile = util$1.promisify(fs__namespace.copyFile);
const fsChmod = util$1.promisify(fs__namespace.chmod);
class util {
    static resolveLookupPaths(pathstr, file) {
        const arr = [];
        const tmp = [];
        pathstr.split(path__namespace.sep).forEach((item) => {
            if (/^[a-zA-Z]:$/.test(item)) {
                // for windows
                return;
            }
            tmp.push(item);
            arr.push(path__namespace.resolve(path__namespace.join(path__namespace.sep, ...tmp, file)));
        });
        return arr.reverse();
    }
    static async tryFiles(paths) {
        for (let i = 0, j = paths.length; i < j; i++) {
            const file = paths[i];
            try {
                await fsAccess(file, fs__namespace.constants.R_OK);
                return file;
            }
            catch (_e) {
                // not exist try next
            }
        }
    }
    static async getConfig(cwd, name = 'static.json') {
        if (!/static\/?$/.test(cwd)) {
            cwd = path__namespace.join(cwd, 'static');
        }
        const paths = this.resolveLookupPaths(cwd, name);
        let f = '', json = {}, fpath = '', dirname = '';
        f = await this.tryFiles(paths);
        if (f) {
            json = require(f);
            fpath = f;
            dirname = path__namespace.dirname(f);
        }
        return { json, fpath, dirname };
    }
    static async getUpdateTime(files) {
        const mtimes = [];
        for (let i = 0, j = files.length; i < j; i++) {
            const v = files[i];
            const stat = await fsStat$1(v);
            mtimes.push(stat.mtime.getTime());
        }
        const updateTime = Math.max.apply(this, mtimes);
        return updateTime;
    }
    static async getContent(files) {
        const arr = files.map((file) => fsReadFile(file, 'utf-8'));
        const res = await Promise.all(arr);
        const objs = {};
        files.forEach((file, index) => {
            objs[file] = res[index];
        });
        return objs;
    }
}

const fsStat = util$1.promisify(fs__namespace.stat);

const types = {
    'application/andrew-inset': ['ez'],
    'application/applixware': ['aw'],
    'application/atom+xml': ['atom'],
    'application/atomcat+xml': ['atomcat'],
    'application/atomsvc+xml': ['atomsvc'],
    'application/bdoc': ['bdoc'],
    'application/ccxml+xml': ['ccxml'],
    'application/cdmi-capability': ['cdmia'],
    'application/cdmi-container': ['cdmic'],
    'application/cdmi-domain': ['cdmid'],
    'application/cdmi-object': ['cdmio'],
    'application/cdmi-queue': ['cdmiq'],
    'application/cu-seeme': ['cu'],
    'application/dash+xml': ['mpd'],
    'application/davmount+xml': ['davmount'],
    'application/docbook+xml': ['dbk'],
    'application/dssc+der': ['dssc'],
    'application/dssc+xml': ['xdssc'],
    'application/ecmascript': ['ecma'],
    'application/emma+xml': ['emma'],
    'application/epub+zip': ['epub'],
    'application/exi': ['exi'],
    'application/font-tdpfr': ['pfr'],
    'application/font-woff': ['woff'],
    'application/geo+json': ['geojson'],
    'application/gml+xml': ['gml'],
    'application/gpx+xml': ['gpx'],
    'application/gxf': ['gxf'],
    'application/gzip': ['gz'],
    'application/hjson': ['hjson'],
    'application/hyperstudio': ['stk'],
    'application/inkml+xml': ['ink', 'inkml'],
    'application/ipfix': ['ipfix'],
    'application/java-archive': ['jar', 'war', 'ear'],
    'application/java-serialized-object': ['ser'],
    'application/java-vm': ['class'],
    'application/javascript': ['js', 'mjs'],
    'application/json': ['json', 'map'],
    'application/json5': ['json5'],
    'application/jsonml+json': ['jsonml'],
    'application/ld+json': ['jsonld'],
    'application/lost+xml': ['lostxml'],
    'application/mac-binhex40': ['hqx'],
    'application/mac-compactpro': ['cpt'],
    'application/mads+xml': ['mads'],
    'application/manifest+json': ['webmanifest'],
    'application/marc': ['mrc'],
    'application/marcxml+xml': ['mrcx'],
    'application/mathematica': ['ma', 'nb', 'mb'],
    'application/mathml+xml': ['mathml'],
    'application/mbox': ['mbox'],
    'application/mediaservercontrol+xml': ['mscml'],
    'application/metalink+xml': ['metalink'],
    'application/metalink4+xml': ['meta4'],
    'application/mets+xml': ['mets'],
    'application/mods+xml': ['mods'],
    'application/mp21': ['m21', 'mp21'],
    'application/mp4': ['mp4s', 'm4p'],
    'application/msword': ['doc', 'dot'],
    'application/mxf': ['mxf'],
    'application/octet-stream': [
        'bin',
        'dms',
        'lrf',
        'mar',
        'so',
        'dist',
        'distz',
        'pkg',
        'bpk',
        'dump',
        'elc',
        'deploy',
        'exe',
        'dll',
        'deb',
        'dmg',
        'iso',
        'img',
        'msi',
        'msp',
        'msm',
        'buffer',
    ],
    'application/oda': ['oda'],
    'application/oebps-package+xml': ['opf'],
    'application/ogg': ['ogx'],
    'application/omdoc+xml': ['omdoc'],
    'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
    'application/oxps': ['oxps'],
    'application/patch-ops-error+xml': ['xer'],
    'application/pdf': ['pdf'],
    'application/pgp-encrypted': ['pgp'],
    'application/pgp-signature': ['asc', 'sig'],
    'application/pics-rules': ['prf'],
    'application/pkcs10': ['p10'],
    'application/pkcs7-mime': ['p7m', 'p7c'],
    'application/pkcs7-signature': ['p7s'],
    'application/pkcs8': ['p8'],
    'application/pkix-attr-cert': ['ac'],
    'application/pkix-cert': ['cer'],
    'application/pkix-crl': ['crl'],
    'application/pkix-pkipath': ['pkipath'],
    'application/pkixcmp': ['pki'],
    'application/pls+xml': ['pls'],
    'application/postscript': ['ai', 'eps', 'ps'],
    'application/pskc+xml': ['pskcxml'],
    'application/raml+yaml': ['raml'],
    'application/rdf+xml': ['rdf'],
    'application/reginfo+xml': ['rif'],
    'application/relax-ng-compact-syntax': ['rnc'],
    'application/resource-lists+xml': ['rl'],
    'application/resource-lists-diff+xml': ['rld'],
    'application/rls-services+xml': ['rs'],
    'application/rpki-ghostbusters': ['gbr'],
    'application/rpki-manifest': ['mft'],
    'application/rpki-roa': ['roa'],
    'application/rsd+xml': ['rsd'],
    'application/rss+xml': ['rss'],
    'application/rtf': ['rtf'],
    'application/sbml+xml': ['sbml'],
    'application/scvp-cv-request': ['scq'],
    'application/scvp-cv-response': ['scs'],
    'application/scvp-vp-request': ['spq'],
    'application/scvp-vp-response': ['spp'],
    'application/sdp': ['sdp'],
    'application/set-payment-initiation': ['setpay'],
    'application/set-registration-initiation': ['setreg'],
    'application/shf+xml': ['shf'],
    'application/smil+xml': ['smi', 'smil'],
    'application/sparql-query': ['rq'],
    'application/sparql-results+xml': ['srx'],
    'application/srgs': ['gram'],
    'application/srgs+xml': ['grxml'],
    'application/sru+xml': ['sru'],
    'application/ssdl+xml': ['ssdl'],
    'application/ssml+xml': ['ssml'],
    'application/tei+xml': ['tei', 'teicorpus'],
    'application/thraud+xml': ['tfi'],
    'application/timestamped-data': ['tsd'],
    'application/voicexml+xml': ['vxml'],
    'application/wasm': ['wasm'],
    'application/widget': ['wgt'],
    'application/winhlp': ['hlp'],
    'application/wsdl+xml': ['wsdl'],
    'application/wspolicy+xml': ['wspolicy'],
    'application/xaml+xml': ['xaml'],
    'application/xcap-diff+xml': ['xdf'],
    'application/xenc+xml': ['xenc'],
    'application/xhtml+xml': ['xhtml', 'xht'],
    'application/xml': ['xml', 'xsl', 'xsd', 'rng'],
    'application/xml-dtd': ['dtd'],
    'application/xop+xml': ['xop'],
    'application/xproc+xml': ['xpl'],
    'application/xslt+xml': ['xslt'],
    'application/xspf+xml': ['xspf'],
    'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],
    'application/yang': ['yang'],
    'application/yin+xml': ['yin'],
    'application/zip': ['zip'],
    'audio/3gpp': ['3gpp'],
    'audio/adpcm': ['adp'],
    'audio/basic': ['au', 'snd'],
    'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
    'audio/mp3': ['mp3'],
    'audio/mp4': ['m4a', 'mp4a'],
    'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
    'audio/ogg': ['oga', 'ogg', 'spx'],
    'audio/s3m': ['s3m'],
    'audio/silk': ['sil'],
    'audio/wav': ['wav'],
    'audio/wave': ['wav'],
    'audio/webm': ['weba'],
    'audio/xm': ['xm'],
    'font/collection': ['ttc'],
    'font/otf': ['otf'],
    'font/ttf': ['ttf'],
    'font/woff': ['woff'],
    'font/woff2': ['woff2'],
    'image/apng': ['apng'],
    'image/bmp': ['bmp'],
    'image/cgm': ['cgm'],
    'image/g3fax': ['g3'],
    'image/gif': ['gif'],
    'image/ief': ['ief'],
    'image/jp2': ['jp2', 'jpg2'],
    'image/jpeg': ['jpeg', 'jpg', 'jpe'],
    'image/jpm': ['jpm'],
    'image/jpx': ['jpx', 'jpf'],
    'image/ktx': ['ktx'],
    'image/png': ['png'],
    'image/sgi': ['sgi'],
    'image/svg+xml': ['svg', 'svgz'],
    'image/tiff': ['tiff', 'tif'],
    'image/webp': ['webp'],
    'message/disposition-notification': ['disposition-notification'],
    'message/global': ['u8msg'],
    'message/global-delivery-status': ['u8dsn'],
    'message/global-disposition-notification': ['u8mdn'],
    'message/global-headers': ['u8hdr'],
    'message/rfc822': ['eml', 'mime'],
    'model/gltf+json': ['gltf'],
    'model/gltf-binary': ['glb'],
    'model/iges': ['igs', 'iges'],
    'model/mesh': ['msh', 'mesh', 'silo'],
    'model/vrml': ['wrl', 'vrml'],
    'model/x3d+binary': ['x3db', 'x3dbz'],
    'model/x3d+vrml': ['x3dv', 'x3dvz'],
    'model/x3d+xml': ['x3d', 'x3dz'],
    'text/cache-manifest': ['appcache', 'manifest'],
    'text/calendar': ['ics', 'ifb'],
    'text/coffeescript': ['coffee', 'litcoffee'],
    'text/css': ['css'],
    'text/csv': ['csv'],
    'text/html': ['html', 'htm', 'shtml'],
    'text/jade': ['jade'],
    'text/jsx': ['jsx'],
    'text/less': ['less'],
    'text/markdown': ['markdown', 'md'],
    'text/mathml': ['mml'],
    'text/n3': ['n3'],
    'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
    'text/richtext': ['rtx'],
    'text/rtf': ['rtf'],
    'text/sgml': ['sgml', 'sgm'],
    'text/shex': ['shex'],
    'text/slim': ['slim', 'slm'],
    'text/stylus': ['stylus', 'styl'],
    'text/tab-separated-values': ['tsv'],
    'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],
    'text/turtle': ['ttl'],
    'text/uri-list': ['uri', 'uris', 'urls'],
    'text/vcard': ['vcard'],
    'text/vtt': ['vtt'],
    'text/xml': ['xml'],
    'text/yaml': ['yaml', 'yml'],
    'video/3gpp': ['3gp', '3gpp'],
    'video/3gpp2': ['3g2'],
    'video/h261': ['h261'],
    'video/h263': ['h263'],
    'video/h264': ['h264'],
    'video/jpeg': ['jpgv'],
    'video/jpm': ['jpm', 'jpgm'],
    'video/mj2': ['mj2', 'mjp2'],
    'video/mp2t': ['ts'],
    'video/mp4': ['mp4', 'mp4v', 'mpg4'],
    'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
    'video/ogg': ['ogv'],
    'video/quicktime': ['qt', 'mov'],
    'video/webm': ['webm'],
};
const typesMap = {};
const defaultMime = 'application/octet-stream';
Object.keys(types).forEach((mimestr) => {
    const item = types[mimestr];
    item.forEach((ext) => {
        typesMap[ext] = mimestr;
    });
});
const resolveMime = (filePath) => {
    const t = filePath.split('.').pop();
    const type = typesMap[t || ''];
    return type ? type : defaultMime;
};
class file {
    static async serve(req, res, pathname, cwd = '.', index = 'index.html') {
        const { text, code, stats, file } = await this.target(pathname, cwd, index);
        if (!stats) {
            res.writeHead(code, {
                'Content-Type': 'text/plain',
                'Content-Length': text.length,
            });
            return res.end(text);
        }
        const info = this.info(req.headers, stats, file);
        return this.pipe(res, info, file);
    }
    static async target(pathname, cwd = '.', index = 'index.html') {
        let file = path__namespace.join(cwd, pathname);
        if (file.endsWith('/')) {
            file = path__namespace.join(file, index);
        }
        if (file.endsWith('/')) {
            return { text: '403 forbidden', code: 403 };
        }
        let stats;
        try {
            stats = await fsStat(file);
        }
        catch (_e) {
            // not exist
            return { text: '404 page not found', code: 404 };
        }
        if (!stats || !stats.isFile()) {
            return { text: '403 forbidden', code: 403 };
        }
        return { code: 200, stats, file, text: '' };
    }
    static info(headers, stats, file) {
        const mime = resolveMime(file);
        const lastModify = new Date(stats.mtimeMs).toUTCString();
        if (headers['last-modified'] == lastModify) {
            return {
                code: 304,
                meta: {
                    'Last-Modified': lastModify,
                    'Content-Type': mime,
                    'Content-Length': 0,
                },
            };
        }
        const matches = headers.range ? headers.range.trim().match(/^bytes=(\d+)-(\d+)?$/) : false;
        if (matches) {
            const start = parseInt(matches[1]);
            let end = matches[2] ? parseInt(matches[2]) : stats.size - 1;
            if (end >= stats.size) {
                end = stats.size - 1;
            }
            if (start > end || start >= stats.size) {
                return {
                    code: 416,
                    meta: {
                        'Content-Length': 0,
                    },
                };
            }
            const len = end - start + 1;
            return {
                code: 206,
                meta: {
                    'Content-Range': `bytes ${start}-${end}/${stats.size}`,
                    'Accept-Ranges': 'bytes',
                    'Content-Type': mime,
                    'Content-Length': len,
                },
                start,
                end,
            };
        }
        return {
            code: 200,
            meta: {
                'Last-Modified': lastModify,
                'Accept-Ranges': 'bytes',
                'Content-Type': mime,
                'Content-Length': stats.size,
            },
        };
    }
    static pipe(res, info, file) {
        const { code, meta, start, end } = info;
        res.writeHead(code, meta);
        if (code == 304 || code == 416) {
            return res.end();
        }
        else if (code == 206) {
            return fs__namespace.createReadStream(file, { start, end }).pipe(res);
        }
        return fs__namespace.createReadStream(file).pipe(res);
    }
}

class route {
    routes = [];
    middlewares = [];
    constructor() {
    }
    get(path, fn) {
        return this.add(path, fn, ['GET']);
    }
    post(path, fn) {
        return this.add(path, fn, ['POST']);
    }
    put(path, fn) {
        return this.add(path, fn, ['PUT']);
    }
    delete(path, fn) {
        return this.add(path, fn, ['DELETE']);
    }
    head(path, fn) {
        return this.add(path, fn, ['HEAD']);
    }
    patch(path, fn) {
        return this.add(path, fn, ['PATCH']);
    }
    options(path, fn) {
        return this.add(path, fn, ['OPTIONS']);
    }
    add(path, fn, method = ["GET", "POST", "PUT", "DELETE", "HEAD", "PATCH", "OPTIONS"], timeout = 5000) {
        this.routes.push({ method, path, fn, timeout });
        return this;
    }
    use(prefix = '', middleware = null, timeout = 5000, method = ["GET", "POST", "PUT", "DELETE", "HEAD", "PATCH", "OPTIONS"]) {
        let path = prefix;
        let handler = middleware;
        if (!handler) {
            path = false;
            handler = prefix;
        }
        this.middlewares.push({ path, handler, timeout, method });
        return this;
    }
    match(m, uri) {
        for (let i = 0, j = this.routes.length; i < j; i++) {
            const { method, path, fn, timeout } = this.routes[i];
            if (method.includes(m) && (!path || path.test(uri))) {
                return { fn, params: uri.match(path), timeout };
            }
        }
        return false;
    }
    async runRoute(req, res, pathname, query) {
        const m = this.match(req.method || 'GET', pathname);
        if (!m) {
            return true;
        }
        const { fn, params, timeout } = m;
        req.ctx.params = params;
        return await new Promise(async (resolve, reject) => {
            const t = setTimeout(() => {
                resolve(false);
            }, timeout);
            try {
                await fn(req, res, pathname, query);
            }
            catch (e) {
                reject(e);
            }
            finally {
                resolve(false);
                clearTimeout(t);
            }
        });
    }
    middlewareMatch(m, uri) {
        const middlewares = [];
        for (let i = 0, j = this.middlewares.length; i < j; i++) {
            const { method, handler, path, timeout } = this.middlewares[i];
            if (method.includes(m) && (!path || path.test(uri))) {
                middlewares.push({ timeout, handler, params: uri.match(path) });
            }
        }
        return middlewares;
    }
    async runMiddleWare(req, res, pathname, query) {
        const m = this.middlewareMatch(req.method || 'GET', pathname);
        req.ctx = {
            params: null,
            run: true,
            middlewares: [],
            routes: []
        };
        for (let i = 0, j = m.length; i < j; i++) {
            const { handler, params, timeout } = m[i];
            const ret = await new Promise(async (resolve, reject) => {
                req.ctx.params = params;
                const t = setTimeout(() => {
                    resolve(false);
                }, timeout);
                const next = () => {
                    clearTimeout(t);
                    resolve(true);
                };
                const stop = () => {
                    clearTimeout(t);
                    resolve(false);
                };
                try {
                    await handler(req, res, next, stop);
                }
                catch (e) {
                    reject(e);
                }
            });
            if (ret === false) {
                return false;
            }
        }
        return true;
    }
}

class servefns extends route {
    constructor() {
        super();
    }
    buildctx(req, res, pathname, query) {
        req.path = pathname;
        req.query = query;
        req.body = this.body(req);
        req.json = this.parseJson(req);
        req.after = (prefix, middleware, timeout = 5000, method = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'PATCH', 'OPTIONS']) => {
            let path = prefix;
            let handler = middleware;
            if (!handler) {
                path = /^\//;
                handler = prefix;
            }
            if (req.ctx) {
                req.ctx.middlewares.push({ path, handler, timeout, method });
            }
            return req;
        };
        res.json = this.sendJson(res);
        res.send = this.sendData(res);
        res.file = this.sendFile(req, res);
    }
    body(request) {
        return async (max = 8192) => {
            return await new Promise((resolve, reject) => {
                const buf = [];
                let count = 0;
                request
                    .on('error', reject)
                    .on('aborted', reject)
                    .on('data', (data) => {
                    buf.push(data);
                    count += data.length;
                    if (count > max) {
                        reject('body too large');
                    }
                })
                    .on('end', () => {
                    resolve(Buffer.concat(buf));
                });
            });
        };
    }
    parseJson(request) {
        return async (max = 8192) => {
            const bodyParser = this.body(request);
            const buf = await bodyParser(max);
            return JSON.parse(buf.toString() || '{}');
        };
    }
    sendJson(response) {
        return (data, status = 200) => {
            const str = JSON.stringify(data);
            response.writeHead(status, {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(str, 'utf8'),
            });
            return response.end(str);
        };
    }
    sendData(response) {
        return (data, type = 'text/html', status = 200) => {
            response.writeHead(status, {
                'Content-Type': type,
                'Content-Length': Buffer.byteLength(data, 'utf8'),
            });
            return response.end(data);
        };
    }
    sendFile(request, response) {
        return (filepath) => {
            return file.serve(request, response, filepath, '.', '');
        };
    }
    static static(dir) {
        return async (request, response, next, stop) => {
            return await file.serve(request, response, request.path, dir) && stop();
        };
    }
}

class nodeserve extends servefns {
    httpser;
    constructor() {
        super();
        this.httpser = this.init();
    }
    init() {
        return http__namespace.createServer(async (request, response) => {
            const errhandler = (e) => {
                console.error(e);
                if (!response.headersSent) {
                    response.writeHead(500);
                }
                if (!response.writableEnded) {
                    response.end(e.message || e.toString());
                }
            };
            try {
                request.once('error', errhandler);
                response.once('error', errhandler);
                const [pathname, qs] = decodeURI(request.url || '').split('?');
                const query = new URLSearchParams(qs);
                this.buildctx(request, response, pathname, query);
                let ret;
                ret = await this.middleware(request, response, pathname, query);
                if (ret) {
                    ret = await this.route(request, response, pathname, query);
                    if (ret) {
                        ret = await this.servestatic(request, response, pathname, query);
                    }
                }
                await this.runAfter(request, response, pathname, query);
            }
            catch (e) {
                errhandler(e);
            }
        });
    }
    listen(...args) {
        return this.httpser.listen(...args);
    }
    async middleware(req, res, pathname, query) {
        const ret = await this.runMiddleWare(req, res, pathname, query);
        return ret && req.ctx.run;
    }
    async route(req, res, pathname, query) {
        const ret = await this.runRoute(req, res, pathname, query);
        return ret && req.ctx.run;
    }
    servestatic(req, res, pathname, query) {
        return file.serve(req, res, pathname);
    }
    getAfter(middlewareList, m, uri) {
        const middlewares = [];
        for (let i = 0, j = middlewareList.length; i < j; i++) {
            const { method, handler, path, timeout } = middlewareList[i];
            if (method.includes(m) && path.test(uri)) {
                middlewares.push({ timeout, handler, params: uri.match(path) });
            }
        }
        return middlewares;
    }
    async runAfter(req, res, pathname, query) {
        const m = this.getAfter(req.ctx.middlewares, req.method || 'GET', pathname);
        for (let i = 0, j = m.length; i < j; i++) {
            const { handler, timeout } = m[i];
            const ret = await new Promise(async (resolve, reject) => {
                const t = setTimeout(() => {
                    resolve(false);
                }, timeout);
                const next = () => {
                    clearTimeout(t);
                    resolve(true);
                };
                const stop = () => {
                    clearTimeout(t);
                    resolve(false);
                };
                try {
                    await handler(req, res, next, stop);
                }
                catch (e) {
                    reject(e);
                }
            });
            if (ret === false) {
                return false;
            }
        }
        return true;
    }
}

const cors = (request, response, next) => {
    const { origin } = request.headers;
    if (origin) {
        response.setHeader('Access-Control-Allow-Origin', origin);
        response.setHeader('Access-Control-Allow-Credentials', 'true');
    }
    else {
        response.setHeader('Access-Control-Allow-Origin', '*');
    }
    response.setHeader('Access-Control-Max-Age', '604800');
    response.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, HEAD, PATCH, OPTIONS');
    response.setHeader('Access-Control-Allow-Headers', 'Range, Origin, X-Requested-With, Content-Type, Content-Length, Accept, Accept-Encoding, Cache-Control, Expires, Pragma');
    response.setHeader('Access-Control-Expose-Headers', 'Content-Length, Accept-Ranges');
    next();
};

const maxItem = 1e3;
const memcaches = new Map();
class default_1 {
    static errorlog = [];
    static log(msg) {
        msg = msg.toString();
        if (this.errorlog.length > maxItem) {
            this.errorlog = [];
        }
        var nowDate = new Date();
        msg = nowDate.toLocaleDateString() + ' ' + nowDate.toLocaleTimeString() + ' ' + msg;
        this.errorlog.push(msg);
        console.log(msg);
    }
    static get(k) {
        return memcaches.get(k);
    }
    static set(k, v) {
        return memcaches.set(k, v);
    }
}

class compress {
    opts;
    pathname;
    query;
    options = {
        urlArgs: '',
        globalVars: {},
        modifyVars: {},
        compress: false,
        math: '',
        env: 'development',
    };
    jopts = { debug: true, clean: false };
    constructor(opts, pathname, query) {
        this.opts = opts;
        this.pathname = pathname;
        this.query = query;
        const lessOptions = opts.opts.lessOptions || {};
        this.options.urlArgs = query.urlArgs
            ? query.urlArgs.toString()
            : process.env.URLARGS || lessOptions.urlArgs || '';
        this.options.globalVars = process.env.GLOBALVARS
            ? querystring__namespace.parse(process.env.GLOBALVARS)
            : lessOptions.globalVars || {};
        this.options.modifyVars = query.modifyVars
            ? querystring__namespace.parse(query.modifyVars.toString())
            : process.env.MODIFYVARS
                ? querystring__namespace.parse(process.env.MODIFYVARS)
                : lessOptions.modifyVars || {};
        this.options.math = lessOptions.math;
    }
    // 解析优先级, 配置文件>连字符>less文件查找>静态文件
    // 连字符这一步:如果带连字符的文件确实存在,则不按照连字符拆分
    async resolveLess() {
        const pathname = this.pathname.replace('.css', '').replace(/^\//, '');
        const css = this.opts.opts.static ? Object.keys(this.opts.opts.static.css) || [] : [];
        // dirname存在说明有配置文件,无配置文件时按照原始地址
        const curr = this.opts.dirname ? pathname.replace(/.*static\//, '') : pathname;
        if (this.opts.dirname && css.includes(curr + '.css')) {
            return this.opts.opts.static.css[curr + '.css'].map((item) => path__namespace.join(this.opts.dirname, item));
        }
        if (/-/.test(curr)) {
            // 如果带有连字符,先看连字符的文件确实不存在再拆分
            try {
                const f = path__namespace.join(this.opts.dirname, curr) + '.css';
                await fsAccess(f, fs__namespace.constants.R_OK);
                // return 单个css地址,后面会当做静态文件输出
                return [f];
            }
            catch (_e) {
                const dirs = pathname.split('/');
                const segment = dirs.pop();
                return segment
                    .split('-')
                    .filter((item) => item)
                    .map((item) => {
                    return path__namespace.join(this.opts.dirname, ...dirs, item) + '.less';
                });
            }
        }
        // 先尝试less文件,无less文件fallback到css
        let target = path__namespace.join(this.opts.dirname, curr) + '.less';
        try {
            await fsAccess(target, fs__namespace.constants.R_OK);
        }
        catch (_e) {
            target = path__namespace.join(this.opts.dirname, curr) + '.css';
        }
        return [target];
    }
    // 解析优先级, 配置文件>连字符>静态文件
    // 连字符这一步:如果带连字符的文件确实存在,则不按照连字符拆分
    async resolveJs() {
        const pathname = this.pathname.replace('.js', '').replace(/^\//, '');
        const js = this.opts.opts.static ? Object.keys(this.opts.opts.static.js) || [] : [];
        // this.opts.dirname存在说明有配置文件,无配置文件按照原始地址
        const curr = this.opts.dirname ? pathname.replace(/.*static\//, '') : pathname;
        if (this.opts.dirname && js.includes(curr + '.js')) {
            return this.opts.opts.static.js[curr + '.js'].map((item) => path__namespace.join(this.opts.dirname, item));
        }
        if (/-/.test(curr)) {
            try {
                const f = path__namespace.join(this.opts.dirname, curr) + '.js';
                await fsAccess(f, fs__namespace.constants.R_OK);
                // return 单个js地址,后面会当做静态文件输出
                return [f];
            }
            catch (_e) {
                const dirs = curr.split('/');
                const segment = dirs.pop();
                return segment
                    .split('-')
                    .filter((item) => item)
                    .map((item) => {
                    return path__namespace.join(this.opts.dirname, ...dirs, item) + '.js';
                });
            }
        }
        return [path__namespace.join(this.opts.dirname, curr) + '.js'];
    }
    async less() {
        const files = await this.resolveLess();
        if (files.length == 1 && files[0].match(/\.css$/)) {
            // 收到标记使用一个css静态文件
            const text = await fsReadFile(files[0]);
            return {
                ret: {
                    css: text,
                },
                hit: false,
            };
        }
        const time = await util.getUpdateTime(files);
        const ret = default_1.get(this.pathname);
        if (ret && ret.time == time && ret.urlArgs == this.options.urlArgs) {
            return { ret, hit: true };
        }
        const r = await this.compileLess(files);
        const res = { css: r, time, urlArgs: this.options.urlArgs };
        default_1.set(this.pathname, res);
        return { ret: res, hit: false };
    }
    async compileLess(files) {
        const lessInput = files
            .map((item) => {
            return '@import "' + item + '";';
        })
            .join('\r\n');
        const { urlArgs, globalVars, modifyVars, compress, env, math } = this.options;
        const less = require('less');
        const autoprefix = require('less-plugin-autoprefix');
        const option = {
            plugins: [new autoprefix({ browsers: ['last 5 versions', 'ie > 9', 'Firefox ESR'] })],
            paths: this.opts.dirname,
            urlArgs,
            globalVars,
            modifyVars,
            compress,
            env,
            math,
        };
        const ret = await less.render(lessInput, option);
        return ret.css;
    }
    async Js() {
        const files = await this.resolveJs();
        if (files.length == 1) {
            // 收到标记使用一个js静态文件,没有什么好合并的,直接输出(这里是http响应)
            const text = await fsReadFile(files[0]);
            return {
                ret: {
                    js: text,
                },
                hit: false,
            };
        }
        const time = await util.getUpdateTime(files);
        const ret = default_1.get(this.pathname);
        if (ret && ret.time == time) {
            return { ret, hit: true };
        }
        const r = await this.compileJs(files);
        const res = { js: r, time };
        default_1.set(this.pathname, res);
        return { ret: res, hit: false };
    }
    async compileJs(files) {
        let options;
        if (this.jopts.debug) {
            options = {
                mangle: false,
                compress: false,
                ecma: 2016,
                keep_classnames: true,
                keep_fnames: true,
                output: {
                    comments: true,
                    beautify: true,
                    ecma: 2016,
                },
            };
        }
        else {
            options = {
                ecma: 5,
                mangle: true,
                compress: {
                    drop_debugger: false,
                    drop_console: false,
                },
                output: {
                    comments: false,
                    beautify: false,
                    ecma: 5,
                },
            };
            if (this.jopts.clean) {
                options.compress.drop_console = true;
                options.compress.drop_debugger = true;
            }
        }
        const filesMap = await util.getContent(files);
        const terser = require('terser');
        const ret = await new Promise((resolve, reject) => {
            const result = terser.minify(filesMap, options);
            const er = result.error;
            if (er) {
                const s = er.toString();
                const { filename, line, col, pos } = er;
                er.toString = () => {
                    return `${filename}: ${s} on line ${line}, ${col}:${pos}`;
                };
                return reject(er);
            }
            resolve(result);
        });
        return ret.code;
    }
    async compress(cliargs) {
        this.options.env = 'production';
        this.options.compress = !cliargs.debug;
        this.jopts.debug = cliargs.debug;
        this.jopts.clean = cliargs.clean;
        const { css, js } = this.opts.opts.static;
        for (const item in css) {
            const source = css[item];
            const ret = await this.compileLess(source);
            await fsWriteFile(path__namespace.join(this.opts.dirname, item), ret);
        }
        for (const item in js) {
            const source = js[item].map((item) => path__namespace.join(this.opts.dirname, item));
            const ret = await this.compileJs(source);
            await fsWriteFile(path__namespace.join(this.opts.dirname, item), ret);
        }
    }
    async compressLessOrJs(cliargs, less, js) {
        this.options.env = 'production';
        this.options.compress = !cliargs.debug;
        this.jopts.debug = cliargs.debug;
        this.jopts.clean = cliargs.clean;
        if (less.length > 0) {
            const cssdst = less[0].replace(/\.less$/, '.min.css');
            const cssret = await this.compileLess(less);
            await fsWriteFile(cssdst, cssret);
        }
        if (js.length > 0) {
            const jsdst = js[0].replace(/\.js$/, '.min.js');
            const jsret = await this.compileJs(js);
            await fsWriteFile(jsdst, jsret);
        }
    }
}

var utiljs = {
    isFunction(value) {
        return typeof value === 'function';
    },
    isObject(value) {
        return value && typeof value === 'object' && value.constructor === Object;
    },
    unique(arr) {
        return Array.from(new Set(arr));
    },
    getParams(args) {
        const kMap = {
            '-v': 'version',
            '-p': 'port',
            '-o': 'output',
            '-d': 'dir',
            '-q': 'query',
            '-m': 'modifyVars',
            '--escape': 'escape',
            '--debug': 'debug',
            '--clean': 'clean',
            '--dry': 'dry',
            '--cors': 'cors',
            '--art': 'art',
            '--nogit': 'nogit',
            '--lintlast': 'lintlast',
        };
        return this.params(args, kMap);
    },
    params(args, kMap) {
        const ret = {};
        const keys = Object.keys(kMap);
        let key;
        args.forEach((item) => {
            if (keys.includes(item)) {
                if (item.substr(0, 2) == '--') {
                    ret[kMap[item]] = true;
                }
                else {
                    key = kMap[item];
                }
            }
            else if (key && item.toString().charAt(0) != '-') {
                ret[key] = item;
                key = null;
            }
            else {
                key = null;
            }
        });
        return ret;
    },
};

const readFile = util$1.promisify(fs__namespace.readFile);
const includefile = /<!--#\s{1,5}include\s{1,5}file="([\w+/.-]{3,50})"\s{1,5}-->/g;
class ssi {
    cwd;
    pathname;
    query;
    constructor(cwd, pathname, query) {
        this.cwd = cwd;
        this.pathname = pathname;
        this.query = query;
    }
    async html() {
        const main = path__namespace.join(this.cwd, this.pathname);
        return await this.parseHtml(main, this.query, this.cwd);
    }
    async parseHtml(mainfile, query, cwd) {
        const filedir = path__namespace.dirname(mainfile);
        const resfile = await readFile(mainfile);
        let html = resfile.toString();
        let res, i = 0;
        const filesMap = {};
        const fillContents = async () => {
            // 主要目的是将filesMap中的文件都读取缓存起来
            const fileList = Object.keys(filesMap).filter((item) => {
                // 如果文件的内容之前已读取过,则复用,不再readFile
                return !filesMap[item];
            });
            const res = await Promise.all(fileList.map((item) => {
                const f = path__namespace.join(path__namespace.isAbsolute(item) ? cwd : filedir, item);
                return readFile(f);
            }));
            res.forEach((item, i) => {
                filesMap[fileList[i]] = item.toString();
            });
        };
        while (i < 6) {
            const matches = {};
            while ((res = includefile.exec(html))) {
                const [holder, file] = res;
                matches[holder] = file;
                if (!filesMap[file]) {
                    filesMap[file] = '';
                }
            }
            if (Object.keys(matches).length === 0) {
                // // 主html文件内,没有include语法,模板引擎不用处理了,直接返回
                return html;
            }
            i++;
            if (i > 5) {
                throw new Error('include file too deep');
            }
            await fillContents();
            Object.keys(matches).forEach((item) => {
                const file = matches[item];
                const content = filesMap[file];
                html = html.replace(item, content);
            });
        }
    }
}

class template {
    opts;
    cwd;
    pathname;
    query;
    constructor(opts, cwd, pathname, query) {
        this.opts = opts;
        this.cwd = cwd;
        this.pathname = pathname;
        this.query = query;
    }
    art() {
        let file = this.pathname;
        if (file.charAt(0) == '/') {
            file = file.substr(1);
        }
        const template = require('art-template');
        const { minimize, escape } = this.query;
        const options = {
            debug: !minimize,
            minimize,
            compileDebug: !minimize,
            escape: escape,
            root: this.cwd,
            cache: false,
        };
        Object.assign(template.defaults, options);
        const dstfile = path__namespace.join(this.cwd, file);
        let data = this.query ? { ...this.query } : {};
        const config = this.opts.opts;
        if (config.template && config.template[file]) {
            const v = config.template[file];
            let r = {};
            if (utiljs.isObject(v)) {
                r = v;
            }
            else {
                const datafile = path__namespace.join(this.cwd, config.template[file]);
                r = require(datafile);
            }
            data = Object.assign({}, r, data);
        }
        return template(dstfile, Object.keys(data).length > 0 ? data : {});
    }
    async ssi() {
        const s = new ssi(this.cwd, this.pathname, this.query);
        const html = await s.html();
        return html;
    }
}

class server {
    args;
    cliargs;
    cwd;
    app;
    constructor(args, cliargs, cwd) {
        this.args = args;
        this.cliargs = cliargs;
        this.cwd = cwd;
        this.app = new nodeserve();
    }
    serve() {
        try {
            this.route();
            this.app
                .listen(this.args.port, this.args.host, () => {
                console.info('Server listening on port %d', this.args.port);
                this.watch();
            })
                .on('error', (err) => {
                console.error(err.toString());
            });
        }
        catch (e) {
            console.error(e);
        }
    }
    route() {
        if (this.cliargs.cors) {
            this.app.use(cors);
        }
        if (this.cliargs.dry) {
            return;
        }
        this.app.get(/^[\w\-/.]+\.css$/, async (req, res, pathname, query) => {
            const ret = await new compress(this.args.staticCfg, pathname, query).less();
            res.setHeader('Cache-Control', ret.hit ? 5 : 1);
            res.send(ret.ret.css, 'text/css');
        });
        this.app.get(/^[\w\-/.]+\.js$/, async (req, res, pathname, query) => {
            const ret = await new compress(this.args.staticCfg, pathname, query).Js();
            res.setHeader('Cache-Control', ret.hit ? 5 : 1);
            res.send(ret.ret.js, 'text/javascript');
        });
        const tpl = async (req, res, pathname, query) => {
            const tpl = new template(this.args.staticCfg, this.cwd, pathname, query);
            let ret;
            if (this.cliargs.art) {
                ret = await tpl.art();
            }
            else {
                ret = await tpl.ssi();
            }
            res.send(ret);
        };
        this.app.get(/^[\w\-/.]+\.html$/, tpl);
        this.app.get(/^\/$/, (req, res, pathname, query) => {
            return tpl(req, res, '/index.html', query);
        });
    }
    watch() {
        const f = this.args.staticCfg.fpath;
        if (!f) {
            return;
        }
        console.info('load config file ' + f);
        fs__namespace.watchFile(f, () => {
            try {
                delete require.cache[f];
                const c = require(f);
                const newcfg = Object.assign({}, c);
                this.args.staticCfg.opts = newcfg;
                console.info('config reload success ', f);
            }
            catch (e) {
                console.error('config relaod error ', f, e);
            }
        });
    }
}

const version$1 = { eslint: 0, prettier: 0, tsparser: 0, jsparser: 0, vueparser: 0 };
const eslintExtensions = ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.vue'];
const getESLintCLIEngine = (eslintConfig) => {
    const eslint_path = require.resolve('eslint');
    if (!version$1.eslint) {
        console.info('loading', eslint_path);
    }
    const { CLIEngine } = require(eslint_path);
    if (!version$1.eslint) {
        console.info('eslint version ' + CLIEngine.version);
        version$1.eslint = CLIEngine.version;
    }
    return new CLIEngine(eslintConfig);
};
const createPrettify = (formatOptions) => {
    return (text) => {
        const prettier_path = require.resolve('prettier');
        if (!version$1.prettier) {
            console.info('loading', prettier_path);
        }
        const prettier = require(prettier_path);
        if (!version$1.prettier) {
            console.info('prettier version ' + prettier.version);
            version$1.prettier = prettier.version;
        }
        const output = prettier.format(text, formatOptions);
        return output;
    };
};
const createEslintFix = (eslintConfig, fixrules, filePath) => {
    // 此处加载CLIEngine只是为了获取可能存在的配置文件,options.parser必然已设置为空,否则此处直接加载插件,查找目录不正确导致无法加载
    // 下面的require.resolve在安装air目录下的node_modules查找
    const config = getESLintCLIEngine(eslintConfig).getConfigForFile(filePath);
    return async (text, filePath) => {
        const options = {
            ...eslintConfig,
            ...config,
            ...{
                useEslintrc: false,
                fix: true,
            },
        };
        options.rules = { ...options.rules, ...fixrules };
        if (typeof options.globals === 'object') {
            options.globals = Object.entries(options.globals).map(([key, value]) => `${key}:${value}`);
        }
        const fileExtension = path__namespace.extname(filePath || '');
        if (['.ts', '.tsx'].includes(fileExtension)) {
            options.parser = require.resolve('@typescript-eslint/parser');
            if (!version$1.tsparser) {
                console.info('@typescript-eslint/parser ', options.parser);
                version$1.tsparser = options.parser;
            }
            for (const k in options.rules) {
                if (k.includes('vue/')) {
                    options.rules[k] = ['off'];
                }
            }
        }
        if (['.js', '.mjs'].includes(fileExtension)) {
            options.parser = require.resolve('@babel/eslint-parser');
            if (!version$1.jsparser) {
                console.info('@babel/eslint-parser ', options.parser);
                version$1.jsparser = options.parser;
            }
            for (const k in options.rules) {
                if (k.includes('vue/')) {
                    options.rules[k] = ['off'];
                }
            }
        }
        if (['.vue'].includes(fileExtension)) {
            options.parser = require.resolve('vue-eslint-parser');
            if (!version$1.vueparser) {
                console.info('vue-eslint-parser ', options.parser);
                version$1.vueparser = options.parser;
            }
        }
        const cliEngine = getESLintCLIEngine(options);
        const report = cliEngine.executeOnText(text, filePath, true);
        const [{ output = text, errorCount }] = report.results;
        const formatter = await cliEngine.getFormatter('stylish');
        const logoutput = await formatter(report.results);
        if (logoutput) {
            console.info(logoutput);
            if (errorCount > 0) {
                process.exit(1);
            }
        }
        return output;
    };
};
var format = async (options) => {
    const { filePath, text, eslintConfig, prettierOptions, fixrules, prettierLast } = options;
    const fileExtension = path__namespace.extname(filePath || '');
    const onlyPrettier = !eslintExtensions.includes(fileExtension);
    const prettify = createPrettify(prettierOptions);
    if (onlyPrettier) {
        return prettify(text);
    }
    eslintConfig.cwd = path__namespace.dirname(filePath);
    const eslintFix = createEslintFix(eslintConfig, fixrules, filePath);
    if (prettierLast) {
        return await prettify(await eslintFix(text, filePath));
    }
    return await eslintFix(await prettify(text), filePath);
};

const spawn = util$1.promisify(child_process__namespace.spawn);
const spawnSync = child_process__namespace.spawnSync;
const prettyTypes = ['js', 'mjs', 'yml', 'yaml', 'vue', 'jsx', 'ts', 'css', 'less', 'html', 'json', 'scss', 'md'];
const extParser = {
    js: 'babel',
    mjs: 'babel',
    jsx: 'babel',
    ts: 'typescript',
    vue: 'vue',
    html: 'html',
    css: 'css',
    less: 'less',
    scss: 'scss',
    json: 'json',
    md: 'mdx',
    yml: 'yaml',
    yaml: 'yaml',
};
// 修改一些eslint规则来适应prettier
const fixrules = {
    // https://github.com/prettier/eslint-plugin-prettier#arrow-body-style-and-prefer-arrow-callback-issue
    'arrow-body-style': 0,
    'prefer-arrow-callback': 0,
    // https://github.com/prettier/eslint-config-prettier/blob/main/index.js
    curly: ['error', 'all'],
    'lines-around-comment': 0,
    'max-len': 0,
    'no-confusing-arrow': 0,
    'no-mixed-operators': 0,
    'no-tabs': 0,
    'no-unexpected-multiline': 0,
    quotes: 0,
    '@typescript-eslint/quotes': 0,
    'babel/quotes': 0,
    'vue/html-self-closing': 0,
    'vue/max-len': 0,
    // The rest are rules that you never need to enable when using Prettier.
    'array-bracket-newline': 'off',
    'array-bracket-spacing': 'off',
    'array-element-newline': 'off',
    'arrow-parens': 'off',
    'arrow-spacing': 'off',
    'block-spacing': 'off',
    'brace-style': 'off',
    'comma-dangle': 'off',
    'comma-spacing': 'off',
    'comma-style': 'off',
    'computed-property-spacing': 'off',
    'dot-location': 'off',
    'eol-last': 'off',
    'func-call-spacing': 'off',
    'function-call-argument-newline': 'off',
    'function-paren-newline': 'off',
    'generator-star': 'off',
    'generator-star-spacing': 'off',
    'implicit-arrow-linebreak': 'off',
    indent: 'off',
    'jsx-quotes': 'off',
    'key-spacing': 'off',
    'keyword-spacing': 'off',
    'linebreak-style': 'off',
    'multiline-ternary': 'off',
    'newline-per-chained-call': 'off',
    'new-parens': 'off',
    'no-arrow-condition': 'off',
    'no-comma-dangle': 'off',
    'no-extra-parens': 'off',
    'no-extra-semi': 'off',
    'no-floating-decimal': 'off',
    'no-mixed-spaces-and-tabs': 'off',
    'no-multi-spaces': 'off',
    'no-multiple-empty-lines': 'off',
    'no-reserved-keys': 'off',
    'no-space-before-semi': 'off',
    'no-trailing-spaces': 'off',
    'no-whitespace-before-property': 'off',
    'no-wrap-func': 'off',
    'nonblock-statement-body-position': 'off',
    'object-curly-newline': 'off',
    'object-curly-spacing': 'off',
    'object-property-newline': 'off',
    'one-var-declaration-per-line': 'off',
    'operator-linebreak': 'off',
    'padded-blocks': 'off',
    'quote-props': 'off',
    'rest-spread-spacing': 'off',
    semi: 'off',
    'semi-spacing': 'off',
    'semi-style': 'off',
    'space-after-function-name': 'off',
    'space-after-keywords': 'off',
    'space-before-blocks': 'off',
    'space-before-function-paren': 'off',
    'space-before-function-parentheses': 'off',
    'space-before-keywords': 'off',
    'space-in-brackets': 'off',
    'space-in-parens': 'off',
    'space-infix-ops': 'off',
    'space-return-throw-case': 'off',
    'space-unary-ops': 'off',
    'space-unary-word-ops': 'off',
    'switch-colon-spacing': 'off',
    'template-curly-spacing': 'off',
    'template-tag-spacing': 'off',
    'unicode-bom': 'off',
    'wrap-iife': 'off',
    'wrap-regex': 'off',
    'yield-star-spacing': 'off',
    '@babel/object-curly-spacing': 'off',
    '@babel/semi': 'off',
    '@typescript-eslint/brace-style': 'off',
    '@typescript-eslint/comma-dangle': 'off',
    '@typescript-eslint/comma-spacing': 'off',
    '@typescript-eslint/func-call-spacing': 'off',
    '@typescript-eslint/indent': 'off',
    '@typescript-eslint/keyword-spacing': 'off',
    '@typescript-eslint/member-delimiter-style': 'off',
    '@typescript-eslint/no-extra-parens': 'off',
    '@typescript-eslint/no-extra-semi': 'off',
    '@typescript-eslint/object-curly-spacing': 'off',
    '@typescript-eslint/semi': 'off',
    '@typescript-eslint/space-before-function-paren': 'off',
    '@typescript-eslint/space-infix-ops': 'off',
    '@typescript-eslint/type-annotation-spacing': 'off',
    'babel/object-curly-spacing': 'off',
    'babel/semi': 'off',
    'flowtype/boolean-style': 'off',
    'flowtype/delimiter-dangle': 'off',
    'flowtype/generic-spacing': 'off',
    'flowtype/object-type-curly-spacing': 'off',
    'flowtype/object-type-delimiter': 'off',
    'flowtype/quotes': 'off',
    'flowtype/semi': 'off',
    'flowtype/space-after-type-colon': 'off',
    'flowtype/space-before-generic-bracket': 'off',
    'flowtype/space-before-type-colon': 'off',
    'flowtype/union-intersection-spacing': 'off',
    'react/jsx-child-element-spacing': 'off',
    'react/jsx-closing-bracket-location': 'off',
    'react/jsx-closing-tag-location': 'off',
    'react/jsx-curly-newline': 'off',
    'react/jsx-curly-spacing': 'off',
    'react/jsx-equals-spacing': 'off',
    'react/jsx-first-prop-new-line': 'off',
    'react/jsx-indent': 'off',
    'react/jsx-indent-props': 'off',
    'react/jsx-max-props-per-line': 'off',
    'react/jsx-newline': 'off',
    'react/jsx-one-expression-per-line': 'off',
    'react/jsx-props-no-multi-spaces': 'off',
    'react/jsx-tag-spacing': 'off',
    'react/jsx-wrap-multilines': 'off',
    'standard/array-bracket-even-spacing': 'off',
    'standard/computed-property-even-spacing': 'off',
    'standard/object-curly-even-spacing': 'off',
    'unicorn/empty-brace-spaces': 'off',
    'unicorn/no-nested-ternary': 'off',
    'unicorn/number-literal-case': 'off',
    'vue/array-bracket-newline': 'off',
    'vue/array-bracket-spacing': 'off',
    'vue/arrow-spacing': 'off',
    'vue/block-spacing': 'off',
    'vue/block-tag-newline': 'off',
    'vue/brace-style': 'off',
    'vue/comma-dangle': 'off',
    'vue/comma-spacing': 'off',
    'vue/comma-style': 'off',
    'vue/dot-location': 'off',
    'vue/func-call-spacing': 'off',
    'vue/html-closing-bracket-newline': 'off',
    'vue/html-closing-bracket-spacing': 'off',
    'vue/html-end-tags': 'off',
    'vue/html-indent': 'off',
    'vue/html-quotes': 'off',
    'vue/key-spacing': 'off',
    'vue/keyword-spacing': 'off',
    'vue/max-attributes-per-line': 'off',
    'vue/multiline-html-element-content-newline': 'off',
    'vue/mustache-interpolation-spacing': 'off',
    'vue/no-extra-parens': 'off',
    'vue/no-multi-spaces': 'off',
    'vue/no-spaces-around-equal-signs-in-attribute': 'off',
    'vue/object-curly-newline': 'off',
    'vue/object-curly-spacing': 'off',
    'vue/object-property-newline': 'off',
    'vue/operator-linebreak': 'off',
    'vue/script-indent': 'off',
    'vue/singleline-html-element-content-newline': 'off',
    'vue/space-in-parens': 'off',
    'vue/space-infix-ops': 'off',
    'vue/space-unary-ops': 'off',
    'vue/template-curly-spacing': 'off',
};
// no-unused-vars 我们从error修改到了warn
// see https://github.com/eslint/eslint/blob/master/conf/eslint-recommended.js
const rules = {
    'constructor-super': 'error',
    'for-direction': 'error',
    'getter-return': 'error',
    'no-async-promise-executor': 'error',
    'no-case-declarations': 'error',
    'no-class-assign': 'error',
    'no-compare-neg-zero': 'error',
    'no-cond-assign': 'error',
    'no-const-assign': 'error',
    'no-constant-condition': 'error',
    'no-control-regex': 'error',
    'no-debugger': 'error',
    'no-delete-var': 'error',
    'no-dupe-args': 'error',
    'no-dupe-class-members': 'error',
    'no-dupe-else-if': 'error',
    'no-dupe-keys': 'error',
    'no-duplicate-case': 'error',
    'no-empty': 'error',
    'no-empty-character-class': 'error',
    'no-empty-pattern': 'error',
    'no-ex-assign': 'error',
    'no-extra-boolean-cast': 'error',
    'no-extra-semi': 'error',
    'no-fallthrough': 'error',
    'no-func-assign': 'error',
    'no-global-assign': 'error',
    'no-import-assign': 'error',
    'no-inner-declarations': 'error',
    'no-invalid-regexp': 'error',
    'no-irregular-whitespace': 'error',
    'no-loss-of-precision': 'error',
    'no-misleading-character-class': 'error',
    'no-mixed-spaces-and-tabs': 'error',
    'no-new-symbol': 'error',
    'no-nonoctal-decimal-escape': 'error',
    'no-obj-calls': 'error',
    'no-octal': 'error',
    'no-prototype-builtins': 'error',
    'no-redeclare': 'error',
    'no-regex-spaces': 'error',
    'no-self-assign': 'error',
    'no-setter-return': 'error',
    'no-shadow-restricted-names': 'error',
    'no-sparse-arrays': 'error',
    'no-this-before-super': 'error',
    'no-undef': 'error',
    'no-unexpected-multiline': 'error',
    'no-unreachable': 'error',
    'no-unsafe-finally': 'error',
    'no-unsafe-negation': 'error',
    'no-unsafe-optional-chaining': 'error',
    'no-unused-labels': 'error',
    'no-unused-vars': 'warn',
    'no-useless-backreference': 'error',
    'no-useless-catch': 'error',
    'no-useless-escape': 'error',
    'no-with': 'error',
    'require-yield': 'error',
    'use-isnan': 'error',
    'valid-typeof': 'error',
};
const config = {
    eslintConfig: {
        baseConfig: {
            extends: ['plugin:vue/recommended', 'eslint:recommended'],
            rules,
            env: {
                node: true,
                browser: true,
                es2021: true,
                commonjs: true,
                worker: true,
                amd: true,
            },
            parserOptions: {
                ecmaVersion: 12,
                sourceType: 'module',
                requireConfigFile: false,
                allowImportExportEverywhere: true,
                ecmaFeatures: {
                    experimentalObjectRestSpread: true,
                    jsx: true,
                },
            },
            plugins: ['vue'],
            parser: '',
            reportUnusedDisableDirectives: true,
        },
        extends: ['plugin:vue/recommended', 'eslint:recommended'],
        envs: ['node', 'browser', 'es6', 'commonjs', 'worker', 'amd'],
        parserOptions: {
            ecmaVersion: 12,
            sourceType: 'module',
            requireConfigFile: false,
            allowImportExportEverywhere: true,
            ecmaFeatures: {
                experimentalObjectRestSpread: true,
                jsx: true,
            },
        },
        rules,
        globals: ['window', 'console', 'process', 'require', 'Promise', 'Map', 'Set'],
        useEslintrc: true,
        fix: true,
        reportUnusedDisableDirectives: true,
    },
    prettierOptions: {
        printWidth: 120,
        tabWidth: 4,
        singleQuote: true,
        useTabs: true,
        semi: true,
        trailingComma: 'es5',
        quoteProps: 'as-needed',
        bracketSpacing: true,
        arrowParens: 'always',
        endOfLine: 'lf',
        parser: 'babel',
        jsxBracketSameLine: false,
        editorconfig: false,
    },
    fixrules,
    prettierLast: true,
};
const options = {
    dir: 'config',
    git: '.git',
    hooks: 'hooks',
    precommit: 'pre-commit',
    postcommit: 'post-commit',
    commitmsg: 'commit-msg',
};
const stat = fs__namespace.constants.R_OK | fs__namespace.constants.W_OK;
const spawnOps = { stdio: 'inherit', shell: true };
class lint {
    cwd;
    opts;
    files = [];
    constructor(cwd, files, opts) {
        this.cwd = cwd;
        this.opts = opts;
        this.files = files.filter((item) => item.charAt(0) != '-');
        if (this.opts.lintlast) {
            config.prettierLast = false;
        }
    }
    async gitlint() {
        if (this.files.length < 1) {
            return;
        }
        const { prefiles, gitfiles } = this.parse(this.files);
        await this.dolint(prefiles, gitfiles);
        if (!this.opts.nogit) {
            await this.gitadd(gitfiles);
        }
    }
    parse(files) {
        const prefiles = [];
        const gitfiles = [];
        const filetypes = files.map((item) => {
            const name = item.trim();
            const type = item.split('.').pop();
            let p = name;
            if (!path__namespace.isAbsolute(name)) {
                p = path__namespace.join(this.cwd, name);
            }
            if (prettyTypes.includes(type)) {
                prefiles.push(p);
            }
            gitfiles.push(p);
            return { name, path: p, type };
        });
        return { prefiles, gitfiles, filetypes };
    }
    autofiles() {
        const res = spawnSync('git', ['diff', '--name-only', '--diff-filter=ACM']);
        const arrs = res.stdout
            .toString()
            .split('\n')
            .filter((v) => v);
        return arrs;
    }
    async lint() {
        if (this.files.length < 1) {
            this.files = this.autofiles();
        }
        if (this.files.length < 1) {
            return;
        }
        const { prefiles, gitfiles } = this.parse(this.files);
        await this.dolint(prefiles, gitfiles);
    }
    async dolint(prefiles, gitfiles) {
        await this.checkfiles(gitfiles);
        await Promise.all(this.lintConfig(prefiles));
    }
    lintConfig(prefiles) {
        return prefiles.map((item) => {
            return (async () => {
                const r = await fsReadFile(item, 'utf-8');
                if (!r || r.trim().length < 1) {
                    return true;
                }
                const options = {
                    ...config,
                    ...{
                        filePath: item,
                    },
                    ...{
                        text: r,
                    },
                };
                const baseConfig = options.eslintConfig.baseConfig;
                const [preparser, ext] = this.getParser(item);
                options.prettierOptions.parser = preparser;
                if (['mjs', 'js', 'ts', 'tsx'].includes(ext)) {
                    baseConfig.extends = baseConfig.extends.filter((item) => !item.includes('vue'));
                    baseConfig.plugins = baseConfig.plugins.filter((item) => !item.includes('vue'));
                }
                else if (['yml', 'yaml'].includes(ext)) {
                    options.prettierOptions.useTabs = false;
                    options.prettierOptions.tabWidth = 2;
                }
                const res = await format(options);
                if (r !== res && res) {
                    // 异步写文件,其他异步终止进程,容易写出空文件
                    fs__namespace.writeFileSync(item, res);
                }
                console.log(item.replace(this.cwd + '/', ''));
            })();
        });
    }
    getParser(file) {
        const ext = file.split('.').pop().toLowerCase();
        return [extParser[ext] ? extParser[ext] : 'babel', ext];
    }
    gitadd(f) {
        if (f && f.length) {
            return spawn('git', ['add', '-u', f.join(' ')], spawnOps);
        }
        return Promise.resolve();
    }
    async install() {
        const { git, cwd, hooks, precommit, postcommit, commitmsg } = Object.assign({}, options, this.opts);
        const dir = this.opts.dir ? '' : options.dir;
        const prehook = path__namespace.join(this.cwd, dir, precommit);
        const posthook = path__namespace.join(this.cwd, dir, postcommit);
        const msghook = path__namespace.join(this.cwd, dir, commitmsg);
        const predst = path__namespace.join(cwd, git, hooks, precommit);
        const postdst = path__namespace.join(cwd, git, hooks, postcommit);
        const msgdst = path__namespace.join(cwd, git, hooks, commitmsg);
        const mode = 0o755;
        await Promise.all([fsAccess(prehook, stat), fsAccess(posthook, stat), fsAccess(msghook, stat)]);
        await Promise.all([fsCopyFile(prehook, predst), fsCopyFile(posthook, postdst), fsCopyFile(msghook, msgdst)]);
        await Promise.all([fsChmod(predst, mode), fsChmod(postdst, mode), fsChmod(msgdst, mode)]);
    }
    async checkfiles(files) {
        const maxsize = 1048576;
        // 检查文件大小,超过1MB禁止提交
        const stats = await Promise.all(files.map((item) => fsStat$1(item)));
        return stats.every((item, index) => {
            if (item.size > maxsize) {
                throw new Error(`${files[index]} too large,${item.size} exceed ${maxsize}`);
            }
            return true;
        });
    }
    static async commitlint(commitfile) {
        const str = await fsReadFile(commitfile);
        const msg = str.toString();
        if (/Merge\s+branch/i.test(msg)) {
            return;
        }
        if (!/(build|ci|docs|feat|fix|perf|refactor|style|test|revert|chore).{0,2}(\(.{1,100}\))?.{0,2}:.{1,200}/.test(msg)) {
            console.info('commit message should be format like <type>(optional scope): <description>');
            process.exit(1);
        }
    }
}

var help = `
Usage:
    air [command] [flag]
Commands:
    serve           start air http server
    lint            eslint js
    gitlint         lint used for git hook
    compress        compress less or javascript files
    install         install git hooks
    template        use art-template render html
    
Flags:
    -v              show air version
    -h              show this help information
    -p              set server listen port
    -d              document root , work dir, install dir
    -o              set output file path for air template
    -q              urlArgs params in less render
    -m              modifyVars params in less render, eg: env=beta
    --debug         compress with debug mode
    --clean         compress with clean mode,remove console debugger
    --escape        escape when use art-template
    --lintlast      do pretty first and then do eslint
    --nogit         do not integrate with git for gitlint
    --dry           just run as a static server
    --cors          send Access-Control-Allow-Origin
    --art           use art-template instead of ssi
`;
const version = '0.7.23';
const templatetips = `
Usage:
    air template filename.html [flag]

Flags:
    -o              set output file path for air template
    -d              work dir for air template
    --debug         compress with debug mode
    --escape        escape when use template
    --art           use art-template instead of ssi

`;

class command {
    /**
     * air lint --pretty
     * air lint --lintlast
     * @param args
     * @param cwd
     * @param opts
     * @param staticCfg
     */
    static async lint(args, cwd, opts, staticCfg) {
        try {
            await new lint(cwd, args, opts).lint();
        }
        catch (e) {
            console.info(e.message || e.stack || e);
            process.exit(1);
        }
    }
    /**
     * air gitlint --pretty
     * air gitlint --lintlast
     * air gitlint --nogit
     * @param args
     * @param cwd
     * @param opts
     * @param staticCfg
     */
    static async gitlint(args, cwd, opts, staticCfg) {
        try {
            await new lint(cwd, args, opts).gitlint();
        }
        catch (e) {
            console.info(e.message || e.stack || e);
            process.exit(1);
        }
    }
    static async commitlint(args, cwd, opts, staticCfg) {
        await lint.commitlint(args[0]);
    }
    /**
     * air install -dir path/to/dir
     * @param args
     * @param cwd
     * @param opts
     */
    static async install(args, cwd, opts, staticCfg) {
        await new lint(cwd, args, opts).install();
    }
    /**
     * air compress --clean
     * air compress --debug
     * air compress style.less other.less -q urlargs
     * air compress style.less other.less some.js --clean/debug
     * air compress -m env=beta
     * @param args
     * @param cwd
     * @param opts
     */
    static async compress(args, cwd, opts, staticCfg) {
        const fakequery = { urlArgs: opts.query, modifyVars: opts.modifyVars };
        const less = [];
        const js = [];
        args.forEach((item) => {
            if (item.charAt(0) !== '-') {
                const ext = item.split('.').pop();
                if (ext == 'js') {
                    js.push(item);
                }
                else if (ext == 'less') {
                    less.push(item);
                }
            }
        });
        if (less.length > 0 || js.length > 0) {
            return await new compress(staticCfg, '', fakequery).compressLessOrJs(opts, less, js);
        }
        if (!staticCfg.fpath) {
            console.log('no config found');
            return;
        }
        await new compress(staticCfg, '', fakequery).compress(opts);
    }
    /**
     *
     * air template --escape
     * air template --debug
     * @param filename
     * @param data
     * @param options
     */
    static async template(args, cwd, opts, staticCfg) {
        const file = args.filter((item) => item.charAt(0) !== '-')[0];
        if (!file) {
            throw new Error(templatetips);
        }
        const query = { ...process.env, minimize: true, escape: false };
        if (opts.debug) {
            query.minimize = false;
        }
        if (opts.escape) {
            query.escape = true;
        }
        const tpl = new template(staticCfg, cwd, file, query);
        let res;
        if (opts.art) {
            res = await tpl.art();
        }
        else {
            res = await tpl.ssi();
        }
        if (opts.output) {
            return await fsWriteFile(opts.output, res);
        }
        process.stdout.write(res);
    }
}

class cli {
    cwd;
    argv;
    args;
    opts = {
        host: '0.0.0.0',
        port: 8088,
        staticCfg: {
            fpath: '',
            dirname: '',
            opts: {
                lessOptions: {},
                static: {
                    css: null,
                    js: null,
                },
                template: {},
            },
        },
    };
    constructor(cwd) {
        this.cwd = cwd;
    }
    async run(argv) {
        try {
            const [, , ...args] = argv;
            this.argv = args;
            this.args = utiljs.getParams(args);
            this.args.cwd = this.cwd;
            this.opts.port = this.args.port || 8088;
            if (this.args.dir) {
                process.chdir(this.args.dir);
            }
            this.cwd = process.cwd();
            await this.loadConfig();
            if (args.length > 0) {
                await this.runArgs();
            }
            else {
                await this.runInit();
            }
        }
        catch (e) {
            console.error(e.stack || e.message || e);
            process.exit(1);
        }
    }
    async loadConfig() {
        const { json, fpath, dirname } = await util.getConfig(this.cwd);
        this.opts.staticCfg.opts = json;
        this.opts.staticCfg.fpath = fpath;
        this.opts.staticCfg.dirname = dirname;
    }
    /**
    
     * air compress
     * air lint
     * air template
     *
     * air install
     * air gitlint
     * air commitlint
     */
    async runArgs() {
        const [m, ...args] = this.argv;
        const f = command[m];
        if (utiljs.isFunction(f)) {
            return await f.call(command, args, this.cwd, this.args, this.opts.staticCfg);
        }
        return await this.fallback(m, args);
    }
    /**
     * air -p
     * air -d
     * air --dry
     * air --art
     *
     */
    runInit() {
        return new server(this.opts, this.args, this.cwd).serve();
    }
    /**
     *
     * parse flag
     *
     * air -v
     * air -h
     * air serve
     *
     */
    async fallback(m, args) {
        if (['-v'].includes(m) || args.includes('-v')) {
            this.version();
        }
        else if (['serve', '-p', '-d', '--dry', '--art'].includes(m)) {
            await this.runInit();
        }
        else if (this.args.help) {
            this.help();
        }
        else {
            this.help();
        }
    }
    version() {
        console.log('air version: air/' + version);
    }
    help() {
        console.info(help);
    }
}

new cli(process__namespace.cwd()).run(process__namespace.argv);
